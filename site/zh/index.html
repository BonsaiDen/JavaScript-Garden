<!DOCTYPE html><html lang="en"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="A Guide to JavaScript's Quirks and Flaws."><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]-->
</head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/" title="JavaScript Garden in English">en</a></li><li class="active"><a href="/JavaScript-Garden/zh" title="JavaScript Garden in English">zh</a></li></ul></div><ul><li class="nav_intro"><h1><a href="#intro">Intro</a></h1><ul><li><a href="#intro.authors">﻿ 关于作者（The Authors）</a></li><li><a href="#intro.contributors">﻿ 贡献者（Contributors）</a></li><li><a href="#intro.license">﻿ 许可（License）</a></li></ul></li><li class="nav_object"><h1><a href="#object">Objects</a></h1><ul><li><a href="#object.general">﻿ 对象使用和属性（Object Usage and Properties）</a></li><li><a href="#object.prototype">﻿ 原型（The prototype）</a></li><li><a href="#object.hasownproperty">﻿ <code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">﻿ <code>for in</code> 循环（The <code>for in</code> Loop）</a></li></ul></li><li class="nav_function"><h1><a href="#function">Functions</a></h1><ul><li><a href="#function.general">﻿ 函数声明与表达式（Function Declarations and Expressions）</a></li><li><a href="#function.this">﻿ this 的工作原理（How <code>this</code> works）</a></li><li><a href="#function.closures">﻿ 闭包和引用（Closures and references）</a></li><li><a href="#function.arguments">﻿ <code>arguments</code> 对象（The <code>arguments</code> object）</a></li><li><a href="#function.constructors">Constructors</a></li><li><a href="#function.scopes">Scopes and Namespaces</a></li></ul></li><li class="nav_array"><h1><a href="#array">Arrays</a></h1><ul><li><a href="#array.general">Array Iteration and Properties</a></li><li><a href="#array.constructor">The <code>Array</code> Constructor</a></li></ul></li><li class="nav_types"><h1><a href="#types">Types</a></h1><ul><li><a href="#types.equality">Equality and comparisons</a></li><li><a href="#types.typeof">The <code>typeof</code> operator</a></li><li><a href="#types.instanceof">The <code>instanceof</code> operator</a></li><li><a href="#types.casting">Type casting</a></li></ul></li><li class="nav_core"><h1><a href="#core">Core</a></h1><ul><li><a href="#core.eval">Why not to use <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> and <code>null</code></a></li><li><a href="#core.semicolon">Automatic semicolon insertion</a></li></ul></li><li class="nav_other"><h1><a href="#other">Other</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> and <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Intro</h1><div><p><strong>JavaScript 秘密花园</strong>是一个不断更新的文档，主要关心 JavaScript 一些古怪用法。
对于如何避免常见的错误，难以发现的问题，以及性能问题和不好的实践给出建议，
初学者可以籍此深入了解 JavaScript 的语言特性。</p>

<p>JavaScript 秘密花园<strong>不是</strong>用来教你 JavaScript。为了更好的理解这篇文章的内容，
你需要事先学习 JavaScript 的基础知识。在 Mozilla 开发者网络中有一系列非常棒的 JavaScript 学习<a href="https://developer.mozilla.org/en/JavaScript/Guide">向导</a>。</p></div></header><!-- Articles--><article id="intro.authors"><h2>﻿ 关于作者（The Authors）</h2><div><p>这篇文章的作者是两位 Stack Overflow 的用户, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a> （写作） 和 <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> （设计）。</p></div></article><article id="intro.contributors"><h2>﻿ 贡献者（Contributors）</h2><div><ul>
<li><a href="https://github.com/caio">Caio Romão</a> （拼写检查）</li>
<li><a href="https://github.com/blixt">Andreas Blixt</a> （语言修正）</li>
</ul>

<h2>中文翻译（Chinese Translation）</h2>

<ul>
<li><a href="http://cnblogs.com/sanshi/">三生石上</a></li>
</ul></div></article><article id="intro.license"><h2>﻿ 许可（License）</h2><div><p>JavaScript 秘密花园在 <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">MIT license</a> 许可协议下发布，并存放在开源社区 <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>。
如果你发现错误或者打字错误，请 <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">file an issue</a> 或者 pull request。
你也可以在 Stack Overflow 的聊天室 <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavaScript room</a> 找到我们。</p></div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Objects</h1></header><!-- Articles--><article id="object.general"><h2>﻿ 对象使用和属性（Object Usage and Properties）</h2><div><p>JavaScript 中所有变量都是对象，除了两个例外 <a href="#undefined"><code>null</code></a> 和 <a href="#undefined"><code>undefined</code></a>。</p>

<pre><code>false.toString() // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
</code></pre>

<p>一个常见的误解是数字的字面值（literal）不是对象。这是因为 JavaScript 解析器的一个错误，
它试图将<em>点操作符</em>解析为浮点数字面值的一部分。</p>

<pre><code>2.toString(); // 出错：SyntaxError
</code></pre>

<p>有很多变通方法可以让数字的字面值看起来像对象。</p>

<pre><code>2..toString(); // 第二个点号可以正常解析
2 .toString(); // 注意点号前面的空格
(2).toString(); // 2先被计算
</code></pre>

</div><div><h3>对象作为数据类型（Objects as a data type）</h3>

<p>JavaScript 的对象可以作为<a href="http://en.wikipedia.org/wiki/Hashmap"><em>哈希表</em></a>使用，主要用来保存命名的键与值的对应关系。</p>

<p>使用对象的字面语法 - <code>{}</code> - 可以创建一个简单对象。这个新创建的对象从 <code>Object.prototype</code>
<a href="#prototype">继承</a>下面，没有任何<a href="#hasownproperty">自定义属性</a>。</p>

<pre><code>var foo = {}; // 一个空对象

// 一个新对象，拥有一个值为12的自定义属性&#39;test&#39;
var bar = {test: 12}; 
</code></pre>

</div><div><h3>访问属性（Accessing properties）</h3>

<p>有两种方式来访问对象的属性，点操作符或者中括号操作符。</p>

<pre><code>var foo = {name: &#39;Kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // works
</code></pre>

<p>两种语法是等价的，但是中括号操作符在下面两种情况下依然有效
 - 动态设置属性
 - 属性名不是一个有效的变量名（译者注：比如属性名中包含空格，或者属性名是JS的关键词）
（译者注：在 <a href="http://www.jslint.com/">JSLint</a> 语法检测工具中，点操作符是推荐做法）</p>

</div><div><h3>删除属性（Deleting properties）</h3>

<p>删除属性的唯一方法是使用 <code>delete</code> 操作符；设置属性为 <code>undefined</code> 或者 <code>null</code> 并不能真正的删除属性，
而<strong>仅仅</strong>是移除了属性和值的关联。</p>

<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}
</code></pre>

<p>上面的输出结果有 <code>bar undefined</code> 和 <code>foo null</code> - 只有 <code>baz</code> 被真正的删除了，所以从输出结果中消失。</p>

</div><div><h3>属性名的语法（Notation of keys）</h3>

<pre><code>var test = {
    &#39;case&#39;: &#39;I am a keyword so I must be notated as a string&#39;,
    delete: &#39;I am a keyword too so me&#39; // 出错：SyntaxError
};
</code></pre>

<p>对象的属性名可以使用字符串或者普通字符声明。但是由于 JavaScript 解析器的另一个错误设计，
上面的第二种声明方式在 ECMAScript 5 之前会抛出 <code>SyntaxError</code> 的错误。</p>

<p>这个错误的原因是 <code>delete</code> 是 JavaScript 语言的一个<em>关键词</em>；因此为了在更低版本的 JavaScript 引擎下也能正常运行，
必须使用<em>字符串字面值</em>声明方式。</p></div></article><article id="object.prototype"><h2>﻿ 原型（The prototype）</h2><div><p>JavaScript 不包含传统的类继承模型，而是使用 <em>prototypical</em> 原型模型。</p>

<p>虽然这经常被当作是 JavaScript 的缺点被提及，其实基于原型的继承模型比传统的类继承还要强大。
实现传统的类继承模型是很简单，但是实现 JavaScript 中的原型继承则要困难的多。
（It is for example fairly trivial to build a classic model on top of it, while the
other way around is a far more difficult task.）</p>

<p>由于 JavaScript 是唯一一个被广泛使用的基于原型继承的语言，所以理解两种继承模式的差异是需要一定时间的。</p>

<p>第一个不同之处在于 JavaScript 使用<em>原型链</em>的继承方式。</p>

<aside>
  <p><strong>注意:</strong> 简单的使用 <code>Bar.prototype = Foo.prototype</code> 将会导致两个对象共享<strong>相同</strong>的原型。
  因此，改变任意一个对象的原型都会影响到另一个对象的原型，在大多数情况下这不是希望的结果。</p>
</aside>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// 设置Bar的prototype属性为Foo的实例对象
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// 修正Bar.prototype.constructor为Bar本身
Bar.prototype.constructor = Bar;

var test = new Bar() // 创建Bar的一个新实例

// 原型链
test [Bar的实例]
    Bar.prototype [Foo的实例] 
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            {method: ...};
            Object.prototype
                {toString: ... /* etc. */};
</code></pre>

<p>上面的例子中，<code>test</code> 对象从 <code>Bar.prototype</code> 和 <code>Foo.prototype</code> 继承下来；因此，
它能否访问 <code>Foo</code> 的原型方法 <code>method</code>。但是它不能访问 <code>Foo</code> 的实例属性 <code>value</code>，
因为这个属性在<code>Foo</code>的<a href="#constructor">构造函数</a>中定义。
（But it will not have access to the property <code>value</code> of a 
<code>Foo</code> instance, since that property gets defined in the <a href="#constructor">constructor</a>
of <code>Foo</code>. But this constructor has to be called explicitly.）</p>

<p>（译者注：我认为这个描述是错误的，test.value 是可以访问的。
因为在设置 Bar.prototype = new Foo(); 时，<code>value</code> 也就成为 Bar.prototype 上的一个属性。
如果你有不同观点，可以到<a href="http://cnblogs.com/sanshi/">我的博客</a>评论。）</p>

<aside>
  <p><strong>注意:</strong> <strong>不要</strong>使用 <code>Bar.prototype = Foo</code>，因为这不会执行 <code>Foo</code> 的原型，而是指向函数 <code>Foo</code>。
  因此原型链将会回溯到 <code>Function.prototype</code> 而不是 <code>Foo.prototype</code>，因此 <code>method</code> 将不会在 Bar 的原型链上。</p>
</aside>

</div><div><h3>属性查找（Property lookup）</h3>

<p>当查找一个对象的属性时，JavaScript 会<strong>向上</strong>遍历原型链，直到找到给定名称的属性为止。</p>

<p>到查找到达原型链的顶部 - 也就是 <code>Object.prototype</code> - 但是仍然没有找到指定的属性，就会返回 <a href="#undefined">undefined</a>。</p>

</div><div><h3>原型属性（The prototype property）</h3>

<p>当原型属性用来创建原型链时，可以把<strong>任何</strong>类型的值赋给它（prototype）。
然而将原子类型赋给 prototype 的操作将会被忽略。</p>

<pre><code>function Foo() {}
Foo.prototype = 1; // no effect
</code></pre>

<p>而将对象赋值给 prototype，正如上面的例子所示，将会动态的创建原型链。</p>

</div><div><h3>性能（Performance）</h3>

<p>如果一个属性在原型链的上端，则对于查找时间将带来不利影响。特别的，试图获取一个不存在的属性将会遍历整个原型链。</p>

<p>并且，当使用 <a href="#the-for-in-loop">for-in</a> 循环遍历对象的属性时，原型链上的<strong>所有</strong>属性都将被访问。</p>

</div><div><h3>扩展内置类型的原型（Extension of native prototypes）</h3>

<p>一个错误特性被经常使用，那就是扩展 <code>Object.prototype</code> 或者其他内置类型的原型对象。</p>

<p>这种技术被称之为 <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> 并且会破坏<em>封装</em>。虽然它被广泛的应用到一些 JavaScript 类库中比如 <a href="http://prototypejs.org/">Prototype</a>,
但是我仍然不认为为内置类型添加一些<em>非标准</em>的函数是个好主意。</p>

<p>扩展内置类型的<strong>唯一</strong>理由是为了和新的 JavaScript 保持一致，比如 <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>。
（译者注：这是编程领域常用的一种方式，称之为 <a href="http://en.wikipedia.org/wiki/Backport">Backport</a>，也就是将新的补丁添加到老版本中。）</p>

</div><div><h3>总结（In conclusion）</h3>

<p>在写复杂的 JavaScript 应用之前，充分理解原型链继承的工作方式是每个 JavaScript 程序员<strong>必修</strong>的功课。
要提防原型链过长带来的性能问题，并知道如何通过缩短原型链来提高性能。
更进一步，绝对<strong>不要</strong>扩展内置类型的原型，除非是为了和新的 JavaScript 引擎兼容。</p></div></article><article id="object.hasownproperty"><h2>﻿ <code>hasOwnProperty</code></h2><div><p>为了判断一个对象是否包含<em>自定义</em>属性而<em>不是</em><a href="#prototype">原型链</a>上的属性，
我们需要使用继承自 <code>Object.prototype</code> 的 <code>hasOwnProperty</code> 方法。</p>

<aside>
  <p><strong>注意:</strong> 通过判断一个属性是否 <code>undefined</code> 是<strong>不够</strong>的。
  因为一个属性可能确实存在，只不过它的值被设置为 <code>undefined</code>。</p>
</aside>

<p><code>hasOwnProperty</code> 是JavaScript中唯一一个处理属性但是<strong>不需要</strong>查找原型链的方法。</p>

<pre><code>// 修改Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

<p>只有 <code>hasOwnProperty</code> 可以给出正确和期望的结果，这在遍历对象的属性时会很有用。
<strong>没有</strong>其它方法可以用来排除原型链上的属性，而不是定义在对象<em>自身</em>上的属性。</p>

</div><div><h3><code>hasOwnProperty</code> 作为属性（<code>hasOwnProperty</code> as a property）</h3>

<p>JavaScript <strong>不会</strong>保护 <code>hasOwnProperty</code> 被非法占用，因此如果一个对象碰巧存在这个属性，
就需要使用<em>外部</em>的 <code>hasOwnProperty</code> 函数来获取正确的结果。</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // 总是返回 false

// 使用其它对象的 hasOwnProperty，并将其上下为设置为foo
{}.hasOwnProperty.call(foo, &#39;bar&#39;); // true
</code></pre>

</div><div><h3>结论（In conclusion）</h3>

<p>当检查对象上某个属性是否存在时，<code>hasOwnProperty</code> 是<strong>唯一</strong>可用的方法。
同时在使用 <a href="#forinloop"><code>for in</code> loop</a> 遍历对象时，推荐<strong>总是</strong>使用 <code>hasOwnProperty</code> 方法，
这将会避免<a href="#prototype">原型</a>对象扩展带来的干扰。</p></div></article><article id="object.forinloop"><h2>﻿ <code>for in</code> 循环（The <code>for in</code> Loop）</h2><div><p>和 <code>in</code> 操作符一样，<code>for in</code> 循环同样在查找对象属性时遍历原型链上的所有属性。</p>

<aside>
  <p><strong>注意:</strong> <code>for in</code> 循环<strong>不会</strong>遍历那些 <code>enumerable</code> 设置为 <code>false</code> 的属性；比如数组的 <code>length</code> 属性。</p>
</aside>

<pre><code>// 修改 Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // 输出两个属性：bar 和 moo
}
</code></pre>

<p>由于不可能改变 <code>for in</code> 自身的行为，因此有必要过滤出那些不希望出现在循环体中的属性，
这可以通过 <code>Object.prototype</code> 原型上的 <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> 函数来完成。</p>

<aside>
  <p><strong>注意:</strong> 由于 <code>for in</code> 总是要遍历整个原型链，因此如果一个对象的继承层次太深的话会影响性能。</p>
</aside>

</div><div><h3>使用 <code>hasOwnProperty</code> 过滤（Using <code>hasOwnProperty</code> for filtering）</h3>

<pre><code>// foo 变量是上例中的
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>这个版本的代码是唯一正确的写法。由于我们使用了 <code>hasOwnProperty</code>，所以这次<strong>只</strong>输出 <code>moo</code>。
如果不使用 <code>hasOwnProperty</code>，则这段代码在原生对象原型（比如 <code>Object.prototype</code>）被扩展时可能会出错。</p>

<p>一个广泛使用的类库 <a href="http://www.prototypejs.org/">Prototype</a> 就扩展了原生的 JavaScript 对象。
因此，但这个类库被包含在页面中时，不使用 <code>hasOwnProperty</code> 过滤的 <code>for in</code> 循环难免会出问题。</p>

</div><div><h3>最佳实践（Best practices）</h3>

<p>推荐<strong>总是</strong>使用 <code>hasOwnProperty</code>。不要对代码运行的环境做任何假设，不要假设原生对象是否已经被扩展了。</p></div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Functions</h1></header><!-- Articles--><article id="function.general"><h2>﻿ 函数声明与表达式（Function Declarations and Expressions）</h2><div><p>函数是JavaScript中的一等对象，这意味着可以把函数像其它值一样传递。
一个常见的用法是把<em>匿名函数</em>作为回调函数传递对异步函数中。</p>

</div><div><h3>函数声明（The <code>function</code> declaration）</h3>

<pre><code>function foo() {}
</code></pre>

<p>上面的方法会在执行前被 <a href="#scopes">解析（hoisted）</a>，因此它存在于当前上下文的<em>任意</em>一个地方，
即使在函数定义体的上面被调用也是对的。 </p>

<pre><code>foo(); // 正常运行，因为foo在代码运行前已经被创建
function foo() {}
</code></pre>

</div><div><h3>函数赋值表达式（The <code>function</code> expression）</h3>

<pre><code>var foo = function() {};
</code></pre>

<p>这个例子把一个<em>匿名</em>的函数赋值给变量 <code>foo</code>。</p>

<pre><code>foo; // &#39;undefined&#39;
foo(); // 出错：TypeError
var foo = function() {};
</code></pre>

<p>由于 <code>var</code> 定义了一个声明语句，对变量 <code>foo</code> 的解析是在代码运行之前，因此 <code>foo</code> 变量在代码运行时已经被定义过了。</p>

<p>但是由于赋值语句只在运行时执行，因此在相应代码执行之前， <code>foo</code> 的值缺省为 <a href="#undefined">undefined</a>。</p>

</div><div><h3>命名函数的赋值表达式（Named function expression）</h3>

<p>另外一个特殊的情况是将命名函数赋值给一个变量。</p>

<pre><code>var foo = function bar() {
    bar(); // 正常运行
}
bar(); // 出错：ReferenceError
</code></pre>

<p><code>bar</code> 函数声明外是不可见的，这是因为我们已经把函数赋值给了 <code>foo</code>；
然而在 <code>bar</code> 内部依然可见。这是由于 JavaScript 的 <a href="#scopes">命名处理</a> 所致，
函数名在函数内<em>总是</em>可见的。</p></div></article><article id="function.this"><h2>﻿ this 的工作原理（How <code>this</code> works）</h2><div><p>JavaScript 有一套完全不同于其它语言的对 <code>this</code> 的处理机制。
在<strong>五</strong>种不同的情况下 ，<code>this</code> 指向的各不相同。</p>

</div><div><h3>全局范围内（The global scope）</h3>

<pre><code>this;
</code></pre>

<p>当在全部范围内使用 <code>this</code>，它将会指向<em>全局</em>对象。
（译者注：浏览器中运行的JavaScript脚本，这个全局对象是 window）</p>

</div><div><h3>函数调用（Calling a function）</h3>

<pre><code>foo();
</code></pre>

<p>这里 <code>this</code> 也会指向<em>全局</em>对象。</p>

<aside class="es5"><p><strong>ES5 注意:</strong> 在严格模式下（strict mode），不存在全局变量。
  这种情况下 <code>this</code> 将会是 <code>undefined</code>。
  （译者注：ES5指的是ECMAScript 5，是2009-12发布的最新的 JavaScript 版本。）</p>
</aside>

</div><div><h3>方法调用（Calling a method）</h3>

<pre><code>test.foo(); 
</code></pre>

<p>这个例子中，<code>this</code> 指向 <code>test</code> 对象。</p>

</div><div><h3>调用构造函数（Calling a constructor）</h3>

<pre><code>new foo(); 
</code></pre>

<p>如果函数倾向于和 <code>new</code> 关键词一块使用，则我们称这个函数是 <a href="#constructors">构造函数</a>。
在函数内部，<code>this</code> 指向<em>新创建</em>的对象。</p>

</div><div><h3>显式的设置 <code>this</code>（Explicit setting of <code>this</code>）</h3>

<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // 数组将会被扩展，如下所示
foo.call(bar, 1, 2, 3); // 传递到foo的参数是：a = 1, b = 2, c = 3
</code></pre>

<p>当使用 <code>Function.prototype</code> 上的 <code>call</code> 或者 <code>apply</code> 方法时，函数内的 <code>this</code> 将会被
<strong>显式设置</strong>为函数调用的第一个参数。</p>

<p>因此<em>函数调用</em>的规则在上例中已经不适用了，在<code>foo</code> 函数内 <code>this</code> 被设置成了 <code>bar</code>。</p>

<aside>
  <p><strong>注意:</strong> 在对象的字面声明语法中，<code>this</code> <strong>不能</strong>用来指向对象本身。
  因此 <code>var obj = {me: this}</code> 中的 <code>me</code> 不会指向 <code>obj</code>，因为 <code>this</code> 只可能出现在上述的五种情况中。
  （译者注：这个例子中，如果是在浏览器中运行，obj.me等于window对象。）</p>
</aside>

</div><div><h3>常见误解（Common pitfalls）</h3>

<p>尽管大部分的情况都说的过去，不过第一个规则（译者注：这里指的应该是第二个规则，也就是直接调用函数时，<code>this</code> 指向全局对象）
被认为是JavaScript语言另一个错误设计的地方，因为它<strong>从来</strong>就没有实际的用途。</p>

<pre><code>Foo.method = function() {
    function test() {
        // this 将会被设置为全局对象（译者注：浏览器环境中也就是 window 对象）
    }
    test();
}
</code></pre>

<p>一个常见的误解是 <code>test</code> 中的 <code>this</code> 将会指向 <code>Foo</code> 对象，实际上<strong>不是</strong>这样子的。</p>

<p>为了在 <code>test</code> 中获取对 <code>Foo</code> 对象的引用，我们需要在 <code>method</code> 函数内部创建一个局部变量指向 <code>Foo</code> 对象。</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // 使用 that 来指向 Foo 对象
    }
    test();
}
</code></pre>

<p><code>that</code> 只是我们随意起的名字，不过这个名字被广泛的用来指向外部的 <code>this</code> 对象。
在 <a href="#closures">closures</a> 一节，我们可以看到 <code>that</code> 可以作为参数传递。</p>

</div><div><h3>方法的赋值表达式（Assigning methods）</h3>

<p>另一个看起来奇怪的地方是函数别名，也就是将一个方法<strong>赋值</strong>给一个变量。</p>

<pre><code>var test = someObject.methodTest;
test();
</code></pre>

<p>上例中，<code>test</code> 就像一个普通的函数被调用；因此，函数内的 <code>this</code> 将不再被指向到 <code>someObject</code> 对象。</p>

<p>虽然 <code>this</code> 的晚绑定特性似乎并不友好，但是这确实<a href="#prototype">基于原型继承</a>赖以生存的土壤。</p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p>当 <code>method</code> 被调用时，<code>this</code> 将会指向 <code>Bar</code> 的实例对象。</p></div></article><article id="function.closures"><h2>﻿ 闭包和引用（Closures and references）</h2><div><p>闭包是 JavaScript 一个非常重要的特性，这意味着当前作用域<strong>总是</strong>能够访问外部作用域中的变量。
因为 <a href="#scopes">函数</a> 是 JavaScript 中唯一拥有自身作用域的结构，因此闭包的创建依赖于函数。</p>

</div><div><h3>模拟私有变量（Emulating private variables）</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>这里，<code>Counter</code> 函数返回两个闭包，函数 <code>increment</code> 和函数 <code>get</code>。 这两个函数都维持着
对外部作用域 <code>Counter</code> 的引用，因此总可以访问此作用域内定义的变量 <code>count</code>.</p>

</div><div><h3>为什么不可以在外部访问私有变量（Why private variables work）</h3>

<p>因为 JavaScript 中不可以对作用域进行引用或赋值，因此没有办法在外部访问 <code>count</code> 变量。
唯一的途径就是通过那两个闭包。</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>上面的代码<strong>不会</strong>改变定义在 <code>Counter</code> 作用域中的 <code>count</code> 变量的值，因为 <code>foo.hack</code> 没有
定义在那个<strong>作用域</strong>内。它将会创建或者覆盖<em>全局</em>变量 <code>count</code>。</p>

</div><div><h3>循环中的闭包（Closures inside loops）</h3>

<p>一个常见的错误出现在循环中使用闭包，假设我们需要在每次循环中调用循环序号（as if they were
copying the value of the loops index variable.）。</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>上面的代码不会输出数字 <code>0</code> 到 <code>9</code>，而是会输出数字 <code>10</code> 十次。</p>

<p>当 <code>console.log</code> 被调用的时候，<em>匿名</em>函数保持对外部变量 <code>i</code> 的引用，此时 <code>for 循环</code>已经结束， <code>i</code> 的值被修改成了 <code>10</code>. </p>

<p>为了得到想要的结果，需要在每次循环中创建变量 <code>i</code> 的<strong>拷贝</strong>。</p>

</div><div><h3>避免引用错误（Avoiding the reference problem）</h3>

<p>为了正确的获得循环序号，最好使用 <a href="#scopes">匿名包裹器</a>（译者注：其实就是我们通常说的自执行匿名函数）。</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>外部的匿名函数会立即执行，并把 <code>i</code> 作为它的参数，此时函数内 <code>e</code> 变量就拥有了 <code>i</code> 的一个拷贝。</p>

<p>当传递给 <code>setTimeout</code> 的匿名函数执行时，它就拥有了对 <code>e</code> 的引用，而这个值是<strong>不会</strong>被循环改变的。</p>

<p>有另一个方法完成同样的工作；那就是从匿名包装器中返回一个函数。这和上面的代码效果一样。</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre></div></article><article id="function.arguments"><h2>﻿ <code>arguments</code> 对象（The <code>arguments</code> object）</h2><div><p>JavaScript 中每个函数内都能访问一个特别变量 <code>arguments</code>。这个变量维护着所有传递到这个函数中的参数列表。</p>

<aside>
  <p><strong>注意:</strong> 由于 <code>arguments</code> 已经被定义为函数内的一个变量。
  因此通过 <code>var</code> 关键字定义 <code>arguments</code> 或者将 <code>arguments</code> 声明为一个形式参数，
  都将导致原生的 <code>arguments</code> 不会被创建。</p>
</aside>

<p><code>arguments</code> 变量<strong>不是</strong>一个数组（<code>Array</code>）。
尽管在语法上它有数组相关的属性 <code>length</code>，但它不从 <code>Array.prototype</code> 继承，实际上它是一个对象（<code>Object</code>）。</p>

<p>因此，无法对 <code>arguments</code> 变量使用标准的数组方法，比如 <code>push</code>, <code>pop</code> 或者 <code>slice</code>。
虽然使用 <code>for</code> 循环遍历也是可以的，但是为了更好的使用数组方法，最好把它转化为一个真正的数组。</p>

</div><div><h3>转化为数组（Converting to an array）</h3>

<p>下面的代码将会创建一个新的数组，包含所有 <code>arguments</code> 对象中的元素。</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>这个转化比较<strong>慢</strong>，在性能不好的代码中<strong>不推荐</strong>这种做法。</p>

</div><div><h3>传递参数（Passing arguments）</h3>

<p>下面将参数从一个函数传递到另一个函数，是推荐的做法。</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // do stuff here
}
</code></pre>

<p>另一个技巧是同时使用 <code>call</code> 和 <code>apply</code>，创建一个快速的解绑定包装器。</p>

<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Create an unbound version of "method" 
// 输入参数为: this, arg1, arg2...argN
Foo.method = function() {

    // 结果: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};
</code></pre>

<p>译者注：上面的 <code>Foo.method</code> 函数和下面代码的效果是一样的。</p>

<pre><code>Foo.method = function() {
    var args = Array.prototype.slice.call(arguments);
    Foo.prototype.method.apply(args[0], args.slice(1));
};
</code></pre>

</div><div><h3>自动更新（Modification "magic"）</h3>

<p><code>arguments</code> 对象为其内部属性以及函数形式参数创建 <em>getter</em> 和 <em>setter</em> 方法。</p>

<p>因此，改变形参的值会影响到 <code>arguments</code> 对象的值，反之亦然。</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2                                                           

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
</code></pre>

</div><div><h3>性能真相（Performance myths and truths）</h3>

<p><code>arguments</code> 对象总会被创建，除了两个特殊情况 - 作为局部变量声明和作为形式参数。
而不管它是否有被使用。</p>

<p><code>arguments</code> 的 <em>getters</em> 和 <em>setters</em> 方法总会被创佳；因此使用 <code>arguments</code> 对性能不会有什么影响。
除非是需要对 <code>arguments</code> 对象的属性进行多次访问。</p>

<aside class="es5"><p><strong>ES5 提示:</strong> 这些 <em>getters</em> 和 <em>setters</em> 在严格模式下（strict mode）不会被创建。</p>
</aside>

<p>译者注：在 <a href="https://developer.mozilla.org/en/JavaScript/Strict_mode">MDC</a> 中对 <code>strict mode</code> 模式下 <code>arguments</code> 的描述有助于我们的理解。</p>

<pre><code>// 译者注：来自 [MDC][2] 的代码，说明在 ES5 的严格模式下 `arguments` 的特性。
function f(a)
{
  "use strict";
  a = 42;
  return [a, arguments[0]];
}
var pair = f(17);
assert(pair[0] === 42);
assert(pair[1] === 17);
</code></pre>

<p>然而，的确有一种情况会显著的影响现代 JavaScript 引擎的性能。这就是使用 <code>arguments.callee</code>。</p>

<pre><code>function foo() {
    arguments.callee; // do something with this function object
    arguments.callee.caller; // and the calling function object
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // Would normally be inlined...
    }
}
</code></pre>

<p>上面代码中，<code>foo</code> 不再是一个单纯的内联函数 <a href="http://en.wikipedia.org/wiki/Inlining">inlining</a>（译者注：这里指的是解析器可以做内联处理），
因为它需要知道它自己和它的调用者。
这不仅抵消了内联函数带来的性能提升，而且破坏了封装，因此现在函数可能要依赖于特定的上下文。</p>

<p>因此<strong>强烈</strong>建议大家<strong>不要</strong>使用 <code>arguments.callee</code> 和它的属性。</p>

<aside class="es5"><p><strong>ES5 提示:</strong> 在严格模式下，<code>arguments.callee</code> 会报错 <code>TypeError</code>，因为它已经被废除了。</p>
</aside></div></article><article id="function.constructors"><h2>Constructors</h2><div><p>Constructors in JavaScript are yet again different from many other languages. Any
function call that is preceded by the <code>new</code> keyword acts as a constructor.</p>

<p>Inside the constructor - the called function - the value of <code>this</code> refers to a 
newly created <code>Object</code>. The <a href="#object.prototype"><code>prototype</code></a> of this <strong>new</strong> 
object is set to the <code>prototype</code> of the function object that was invoked as the
constructor.</p>

<p>If the function that was called has no explicit <code>return</code> statement, then it
implicitly returns the value of <code>this</code> - the new object. </p>

<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>The above calls <code>Foo</code> as constructor and sets the <code>prototype</code> of the newly
created object to <code>Foo.prototype</code>.</p>

<p>In case of an explicit <code>return</code> statement the function returns the value 
specified that statement, <strong>but only</strong> if the return value is an <code>Object</code>.                                     </p>

<pre><code>function Bar() {
    return 2;
}
new Bar(); // a new object

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // the returned object
</code></pre>

<p>When the <code>new</code> keyword is omitted, the function will <strong>not</strong> return a new object. </p>

<pre><code>function Foo() {
    this.bla = 1; // gets set on the global object
}
Foo(); // undefined
</code></pre>

<p>While the above example might still appear to work in some cases, due to the 
workings of <a href="#function.this"><code>this</code></a> in JavaScript, it will use the 
<em>global object</em> as the value of <code>this</code>.</p>

</div><div><h3>Factories</h3>

<p>In order to be able to omit the <code>new</code> keyword, the constructor function has to 
explicitly return a value.</p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
</code></pre>

<p>Both calls to <code>Bar</code> return the exact same thing, a newly create object which
has a property called <code>method</code> on it, that is a 
<a href="#function.closures">Closure</a>.</p>

<p>It is also to note that the call <code>new Bar()</code> does <strong>not</strong> affect the prototype 
of the returned object. While the prototype will be set on the newly created 
object, <code>Bar</code> never returns that new object.</p>

<p>In the above example, there is no functional difference between using and
not using the <code>new</code> keyword.</p>

</div><div><h3>Creating new objects via factories</h3>

<p>An often made recommendation is to <strong>not</strong> use <code>new</code> since forgetting its use
may lead to bugs.</p>

<p>In order to create new object, one should rather use a factory and construct a 
new object inside of that factory.</p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
</code></pre>

<p>While the above is robust against a missing <code>new</code> keyword and certainly makes 
the use of <a href="#function.closures">private variables</a> easier, it comes with some 
downsides.</p>

<ol>
<li>It uses more memory since the created objects do <strong>not</strong> share the methods
on a prototype.</li>
<li>In order to inherit the factory needs to copy all the methods from another
object or put that object on the prototype of the new object.</li>
<li>Dropping the prototype chain just because of a left out <code>new</code> keyword
somehow goes against the spirit of the language.</li>
</ol>

</div><div><h3>In conclusion</h3>

<p>While omitting the <code>new</code> keyword might lead to bugs, it is certainly <strong>not</strong> a 
reason to drop the use of prototypes altogether. In the end it comes down to 
which solution is better suited for the needs of the application, it is 
especially important to choose a specific style of object creation <strong>and stick</strong> 
with it.</p></div></article><article id="function.scopes"><h2>Scopes and Namespaces</h2><div><p>Although JavaScript deals fine with the syntax of two matching curly
braces for blocks, it does <strong>not</strong> support block scope; hence, all that is left 
is in the language is <em>function scope</em>.</p>

<pre><code>function test() { // a scope
    for(var i = 0; i &lt; 10; i++) { // not a scope
        // count
    }
    console.log(i); // 10
}
</code></pre>

<aside>
  <p><strong>Note:</strong> When not used in an assignment, return statement or as a function 
  argument, the <code>{...}</code> notation will get interpreted as a block statement and 
  <strong>not</strong> as an object literal. This, in conjunction with 
  <a href="#core.semicolon">automatic insertion of semicolons</a>, can lead to subtle errors.</p>
</aside>

<p>There are also no distinct namespaces in JavaScript, that means that everything 
gets defined in one <em>globally shared</em> namespace.</p>

<p>Each time a variable is referenced, JavaScript will traverse upwards through all 
the scopes until it finds it. In the case that it reaches the global scope and 
still has not found the requested name, it will raise a <code>ReferenceError</code>.</p>

</div><div><h3>The bane of global variables</h3>

<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;
</code></pre>

<p>The above two scripts do <strong>not</strong> have the same effect. Script A defines a 
variable called <code>foo</code> in the <em>global</em> scope and script B defines a <code>foo</code> in the
<em>current</em> scope.</p>

<p>Again, that is <strong>not</strong> at all the <em>same effect</em>, not using <code>var</code> can have major 
implications.</p>

<pre><code>// global scope
var foo = 42;
function test() {
    // local scope
    foo = 21;
}
test();
foo; // 21
</code></pre>

<p>Leaving out the <code>var</code> statement inside the function <code>test</code> will override the 
value of <code>foo</code>. While this might not seem like a big deal at first, having 
thousands of lines of JavaScript and not using <code>var</code> will introduce horrible and 
hard to track down bugs.</p>

<pre><code>// global scope
var items = [/* some list */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // scope of subLoop
    for(i = 0; i &lt; 10; i++) { // missing var statement
        // do amazing stuff!
    }
}
</code></pre>

<p>The outer loop will terminate after the first call to <code>subLoop</code>,  since <code>subLoop</code>
overwrites the global value of <code>i</code>. Using a <code>var</code> for the second <code>for</code> loop would
have easily avoided this error. The <code>var</code> statement should <strong>never</strong> be left out 
unless the <em>desired effect</em> is to affect the outer scope.</p>

</div><div><h3>Local variables</h3>

<p>The only source for local variables in JavaScript are
<a href="#function.general">function</a> parameters and variables that were declared via the 
<code>var</code> statement.</p>

<pre><code>// global scope
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // local scope of the function test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
</code></pre>

<p>While <code>foo</code> and <code>i</code> are local variables inside the scope of the function <code>test</code>,
the assignment of <code>bar</code> will override the global variable with the same name.</p>

</div><div><h3>Hoisting</h3>

<p>JavaScript <strong>hoists</strong> declarations. This means that both <code>var</code> statements and
<code>function</code> declarations will be moved to the top of their enclosing scope.</p>

<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}
</code></pre>

<p>The above code gets transformed before any execution is started. JavaScript moves
the <code>var</code> statements as well as the <code>function</code> declarations to the top of the 
nearest surrounding scope.</p>

<pre><code>// var statements got moved here
var bar, someValue; // default to &#39;undefined&#39;

// the function declartion got moved up too
function test(data) {
    var goo, i, e; // missing block scope moves these here
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // fails with a TypeError since bar is still &#39;undefined&#39;
someValue = 42; // assignments are not affected by hoisting
bar = function() {};

test();
</code></pre>

<p>Missing block scoping will not only move <code>var</code> statements out of loops and
their bodies, it will also make the results of certain <code>if</code> constructs 
non-intuitive.</p>

<p>In the original code the <code>if</code> statement seemed to modify the <em>global 
variable</em> <code>goo</code>, while actually it modifies the <em>local variable</em> - after hoisting 
has been applied.</p>

<p>Without the knowledge about <em>hoisting</em>, below code might seem to raise a 
<code>ReferenceError</code>.</p>

<pre><code>// check whether SomeImportantThing has been initiliazed
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>

<p>But of course, the above works due to the fact that the <code>var</code> statement is being 
moved to the top of the <em>global scope</em>.</p>

<pre><code>var SomeImportantThing;

// other code might initiliaze SomeImportantThing here, or not

// make sure it&#39;s there
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
</code></pre>

</div><div><h3>Name resolution order</h3>

<p>All scopes in JavaScript, including the <em>global scope</em>, have the special name 
<a href="#function.this"><code>this</code></a> defined in them, which refers to the <em>current object</em>. </p>

<p>Function scopes also have the name <a href="#function.arguments"><code>arguments</code></a> defined in
them which contains the arguments that were passed to a function.</p>

<p>For example, when trying to access a variable named <code>foo</code> inside the scope of a 
function, JavaScript will lookup the name in the following order:</p>

<ol>
<li>In case there is a <code>var foo</code> statement in the current scope use that.</li>
<li>If one of the function parameters is named <code>foo</code> use that.</li>
<li>If the function itself is called <code>foo</code> use that.</li>
<li>Go to the next outer scope and start with <strong>#1</strong> again.</li>
</ol>

<aside>
  <p><strong>Note:</strong> Having a parameter called <code>arguments</code> will <strong>prevent</strong> the creation 
  of the default <code>arguments</code> object.</p>
</aside>

</div><div><h3>Namespaces</h3>

<p>A common problem of having only one global namespace is the likeliness of running
into problems where variable names clash. In JavaScript, this problem can
easily be avoided with the help of <em>anonymous wrappers</em>.</p>

<pre><code>(function() {
    // a self contained "namespace"

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately
</code></pre>

<p>Unnamed functions are considered <a href="#function.general">expressions</a>; so in order to
being callable, they must first be evaluated.</p>

<pre><code>( // evaluate the function inside the paranthesis
function() {}
) // and return the function object
() // call the result of the evaluation
</code></pre>

<p>There are other ways for evaluating and calling the function expression; which, 
while different in syntax, do behave the exact same way.</p>

<pre><code>// Two other ways
+function(){}();
(function(){}());
</code></pre>

</div><div><h3>In conclusion</h3>

<p>It is recommended to always use an <em>anonymous wrapper</em> for encapsulating code in 
its own namespace. This does not only protect code against name clashes, it 
also allows for better modularization of programs.</p>

<p>Additionally, the use of global variables is considered <strong>bad practice</strong>. <strong>Any</strong>
use of them indicates badly written code that is prone to errors and hard to maintain.</p></div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Arrays</h1></header><!-- Articles--><article id="array.general"><h2>Array Iteration and Properties</h2><div><p>Although arrays in JavaScript are objects, there are no good reasons to use
the <a href="#object.forinloop"><code>for in loop</code></a> in for iteration on them. In fact there 
are a number of good reasons <strong>against</strong> the use of <code>for in</code> on arrays.</p>

<aside>
  <p><strong>Note:</strong> JavaScript arrays are <strong>not</strong> <em>associative arrays</em>. JavaScript only 
  has <a href="#object.general">objects</a> for mapping keys to values. And while associative 
  arrays <strong>preserve</strong> order, objects <strong>do not</strong>.</p>
</aside>

<p>Since the <code>for in</code> loop enumerates all the properties that are on the prototype 
chain and the only way to exclude those properties is to use 
<a href="#object.hasownproperty"><code>hasOwnProperty</code></a>, it is already up to <strong>twenty times</strong> 
slower than a normal <code>for</code> loop.</p>

</div><div><h3>Iteration</h3>

<p>In order to achieve the best performance when iterating over arrays, it is best
to use the classic <code>for</code> loop.</p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>There is one extra catch in the above example, that is the caching of the 
length of the array via <code>l = list.length</code>.</p>

<p>Although the <code>length</code> property is defined on the array itself, there is still an
overhead for doing the lookup on each iteration of the loop. And while recent 
JavaScript engines <strong>may</strong> apply optimization in this case, there is no way of
telling whether the code will run on one of these newer engines or not. </p>

<p>In fact, leaving out the caching may result in the loop being only <strong>half as
fast</strong> as with the cached length.</p>

</div><div><h3>The <code>length</code> property</h3>

<p>While the <em>getter</em> of the <code>length</code> property simply returns the number of
elements that are contained in the array, the <em>setter</em> can be used to 
<strong>truncate</strong> the array.</p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>Assigning a smaller length does truncate the array, but increasing the length 
does not have any effect on the array.</p>

</div><div><h3>In conclusion</h3>

<p>For the best performance it is recommended to always use the plain <code>for</code> loop
and cache the <code>length</code> property. The use of <code>for in</code> on an array is a sign of
badly written code that is prone to bugs and bad performance. </p></div></article><article id="array.constructor"><h2>The <code>Array</code> Constructor</h2><div><p>Since the <code>Array</code> constructor is ambiguous in how it deals with its parameters,
it is highly recommended to always use the array literals - <code>[]</code> notation - 
when creating new arrays.</p>

<pre><code>[1, 2, 3]; // Result: [1, 2, 3]
new Array(1, 2, 3); // Result: [1, 2, 3]

[3]; // Result: [3]
new Array(3); // Result: []
new Array(&#39;3&#39;) // Result: [&#39;3&#39;]
</code></pre>

<p>In cases when there is only one argument passed to the <code>Array</code> constructor,
and that argument is a <code>Number</code>, the constructor will return a new <em>sparse</em> 
array with the <code>length</code> property set to the value of the argument. It should be 
noted that <strong>only</strong> the <code>length</code> property of the new array will be set this way, 
the actual indexes of the array will not be initialized. </p>

<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, the index was not set
</code></pre>

<p>The behavior of being able to set the length of the array upfront only comes in 
handy in a few cases, like repeating a string, in which it avoids the use of a 
<code>for loop</code> code.</p>

<pre><code>new Array(count + 1).join(stringToRepeat);
</code></pre>

</div><div><h3>In conclusion</h3>

<p>The use of the <code>Array</code> constructor should be avoided as much as possible. 
Literals are definitely preferred. They are shorter and have a clearer syntax; 
therefore, they also increase the readability of the code.</p></div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Types</h1></header><!-- Articles--><article id="types.equality"><h2>Equality and comparisons</h2><div><p>JavaScript has two different ways of comparing the values of objects for equality. </p>

</div><div><h3>The equals operator</h3>

<p>The equals operator consists of two equal signs: <code>==</code></p>

<p>JavaScript features <em>weak typing</em>, that means, that the equals operator 
<strong>coerces</strong> types in order to compare them.</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>The above table shows the results of the type coercion and it is the main reason 
why the use of <code>==</code> is widely regarded as bad practice, it introduces hard to 
track down bugs due to its complicated conversion rules.</p>

<p>Additionally there is also a performance impact when type coercion is in play;
for example, a string has to be converted to a number before it can be compared
to another number.</p>

</div><div><h3>The strict equals operator</h3>

<p>The strict equals operator consists of <strong>three</strong> equal signs: <code>===</code></p>

<p>Other than the normal equals operator, the strict equals operator does <strong>not</strong>
perform type coercion between its operands.</p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>The above results are a lot clearer and allow for early breakage of code. This
hardens code to a certain degree and also gives performance improvements in case
the operands are of different types.</p>

</div><div><h3>Comparing objects</h3>

<p>While both <code>==</code> and <code>===</code> are stated as <strong>equality</strong> operators, they behave 
different when at least one of their operands happens to be an <code>Object</code>.</p>

<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
</code></pre>

<p>Here both operators compare for <strong>identity</strong> and <strong>not</strong> equality; that is, they
will compare for the same <strong>instance</strong> of the object, much like <code>is</code> in Python 
and a pointer comparison in C do.</p>

</div><div><h3>In conclusion</h3>

<p>It is highly recommended to only use the <strong>strict equals</strong> operator. In cases
where types need to be coerced, it should be done <a href="#types.casting">explicitly</a> 
and not left to the language&#39;s complicated coercion rules.</p></div></article><article id="types.typeof"><h2>The <code>typeof</code> operator</h2><div><p>The <code>typeof</code> operator (together with 
<a href="#types.instanceof"><code>instanceof</code></a>) is probably the biggest 
design flaw of JavaScript, as it is near of being <strong>completely broken</strong>.</p>

<p>Although <code>instanceof</code> still has its limited uses, <code>typeof</code> really has only one
practical use case, which does <strong>not</strong> happen to be checking the type of an 
object. </p>

<aside>
  <p><strong>Note:</strong> While <code>typeof</code> can also be called with a function like syntax
  i.e. <code>typeof(obj)</code>, this is not a function call. The two parenthesis will
  behave like normal and the return value will be used as the operand of the
  <code>typeof</code> operator. There is <strong>no</strong> <code>typeof</code> function.</p>
</aside>

</div><div><h3>The JavaScript type table</h3>

<pre><code>Value               Class      Type
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp("meow")  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>In the above table <em>Type</em> refers to the value, that the <code>typeof</code> operator returns.
As can be clearly seen, this value is anything but consistent.</p>

<p>The <em>Class</em> refers to the value of the internal <code>[[Class]]</code> property of an object.</p>

<aside>
  <p><strong>From the Specification:</strong> The value of <code>[[Class]]</code> can be one of the
  following strings. <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, 
  <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>

<p>In order to retrieve the value of <code>[[Class]]</code> one has to make use of the
<code>toString</code> method of <code>Object.prototype</code>.</p>

</div><div><h3>The Class of an object</h3>

<p>The specification gives exactly one way of accessing the <code>[[Class]]</code> value,
with the use of <code>Object.prototype.toString</code>. </p>

<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
</code></pre>

<p>In the above example, <code>Object.prototype.toString</code> gets called with the value of
<a href="#function.this">this</a> being set to the object whose <code>[[Class]]</code> value should be 
retrieved.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> For convenience the return value of <code>Object.prototype.toString</code> 
  for both <code>null</code> and <code>undefined</code> was <strong>changed</strong> from <code>Object</code> to <code>Null</code> and 
  <code>Undefined</code> in ECMAScript 5.</p>
</aside>

</div><div><h3>Testing for undefined variables</h3>

<pre><code>typeof foo !== &#39;undefined&#39;
</code></pre>

<p>The above will check whether <code>foo</code> was actually declared or not; just 
referencing it would result in a <code>ReferenceError</code>. This is the only thing
<code>typeof</code> is actually useful for.</p>

</div><div><h3>In conclusion</h3>

<p>In order to check the type of an object, it is highly recommended to use 
<code>Object.prototype.toString</code>; as this is the only reliable way of doing so. 
As shown in the above type table, some return values of <code>typeof</code> are not defined 
in the specification; thus, they can differ across various implementations.</p>

<p>Unless checking whether a variable is defined, <code>typeof</code> should be avoided at
<strong>all costs</strong>.</p></div></article><article id="types.instanceof"><h2>The <code>instanceof</code> operator</h2><div><p>The <code>instanceof</code> operator compares the constructors of its two operands. It is 
only useful when comparing custom made objects. Used on built-in types, it is
nearly as useless as the <a href="#types.typeof">typeof operator</a>.</p>

</div><div><h3>Comparing custom objects</h3>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// This just sets Bar.prototype to the function object Foo
// But not to an actual instance of Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
</code></pre>

</div><div><h3>Using <code>instanceof</code> with native types</h3>

<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
</code></pre>

<p>One important thing to note here is, that <code>instanceof</code> does not work on objects 
that origin from different JavaScript contexts (e.g. different documents
in a web browser), since their constructors will not be the exact same object.</p>

</div><div><h3>In conclusion</h3>

<p>The <code>instanceof</code> operator should <strong>only</strong> be used when dealing with custom made 
objects that origin from the same JavaScript context. Just like the
<a href="#types.typeof"><code>typeof</code></a> operator, every other use of it should be <strong>avoided</strong>.</p></div></article><article id="types.casting"><h2>Type casting</h2><div><p>JavaScript is a <em>weakly typed</em> language, so it will apply <em>type coercion</em>
<strong>wherever</strong> possible.</p>

<pre><code>// These are true
new Number(10) == 10; // Number.toString() is converted
                      // back to a number

10 == &#39;10&#39;;           // Strings gets converted to Number
10 == &#39;+10 &#39;;         // More string madness
10 == &#39;010&#39;;          // And more 
isNaN(null) == false; // null converts to 0
                      // which of course is not NaN

// These are false
10 == 010;
10 == &#39;-10&#39;;
</code></pre>

<aside class="es5"><p><strong>ES5 Note:</strong> Number literals that start with a <code>0</code> are interpreted as octal 
  (Base 8). Octal support for these has been <strong>removed</strong> in ECMAScript 5 strict 
  mode.</p>
</aside>

<p>In order to avoid the above, use of the <a href="#types.equality">strict equal operator</a> 
is <strong>highly</strong> recommended. Although this avoids a lot of common pitfalls, there 
are still many further issues that arise from JavaScript&#39;s weak typing system.</p>

</div><div><h3>Constructors of built-in types</h3>

<p>The constructors of the built in types like <code>Number</code> and <code>String</code> behave
differently when being used with the <code>new</code> keyword and without it.</p>

<pre><code>new Number(10) === 10;     // False, Object and Number
Number(10) === 10;         // True, Number and Number
new Number(10) + 0 === 10; // True, due to implicit conversion
</code></pre>

<p>Using a built-in type like <code>Number</code> as a constructor will create a new <code>Number</code> 
object, but leaving out the <code>new</code> keyword will make the <code>Number</code> function behave
like a converter.</p>

<p>In addition, having literals or non-object values in there will result in even
more type coercion.</p>

<p>The best option is to cast to one of the three possible types <strong>explicitly</strong>.</p>

</div><div><h3>Casting to a string</h3>

<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true
</code></pre>

<p>By prepending a empty string a value can easily be casted to a string.</p>

</div><div><h3>Casting to a number</h3>

<pre><code>+&#39;10&#39; === 10; // true
</code></pre>

<p>Using the <strong>unary</strong> plus operator it is possible to cast to a number.</p>

</div><div><h3>Casting to a boolean</h3>

<p>By using the <strong>not</strong> operator twice, a value can be converted a boolean.</p>

<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
</code></pre></div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Core</h1></header><!-- Articles--><article id="core.eval"><h2>Why not to use <code>eval</code></h2><div><p>The <code>eval</code> function will execute a string of JavaScript code in the local scope.</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1
</code></pre>

<p>But <code>eval</code> only executes in local scope when it is being called <strong>directly</strong> <em>and</em> 
the name of the called function is actually <code>eval</code>.</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3
</code></pre>

<p>The use of <code>eval</code> should be avoided at <strong>all costs</strong>. 99.9% of its "uses" can be
achieved <strong>without</strong> it.</p>

</div><div><h3><code>eval</code> in disguise</h3>

<p>The <a href="#other.timeouts">timeout functions</a> <code>setTimeout</code> and <code>setInterval</code> can both 
take a string as their first argument. This string will <strong>always</strong> get executed 
in the global scope since <code>eval</code> is not being called directly in that case.</p>

</div><div><h3>Security issues</h3>

<p><code>eval</code> also is a security problem as it executes <strong>any</strong> code given to it,
it should <strong>never</strong> be used with strings of unknown or untrusted origins.</p>

</div><div><h3>In conclusion</h3>

<p><code>eval</code> should never be used, any code that makes use of it is to be questioned in
its workings, performance and security. In case something requires <code>eval</code> in 
order to work, its design is to be questioned and should <strong>not</strong> be used in the 
first place, a <em>better design</em> should be used, that does not require the use of 
<code>eval</code>. </p></div></article><article id="core.undefined"><h2><code>undefined</code> and <code>null</code></h2><div><p>JavaScript has two distinct values for <code>nothing</code>, the more useful of these two
being <code>undefined</code>.</p>

</div><div><h3>The value <code>undefined</code></h3>

<p><code>undefined</code> is a type with exactly one value: <code>undefined</code>.</p>

<p>The language also defines a global variable that has the value of <code>undefined</code>,
this variable is also called <code>undefined</code>. But this variable is <strong>not</strong> a constant,
nor is it a keyword of the language. This means that its <em>value</em> can be easily 
overwritten.</p>

<aside class="es5"><p><strong>ES5 Note:</strong> <code>undefined</code> in ECMAScript 5 is <strong>no longer</strong> <em>writable</em> in strict
  mode, but its name can still be shadowed by for example a function with the name 
  <code>undefined</code>.</p>
</aside>

<p>Some examples for when the value <code>undefined</code> is returned:</p>

<ul>
<li>Accessing the (unmodified) global variable <code>undefined</code>.</li>
<li>Implicit returns of functions due to missing <code>return</code> statements.</li>
<li><code>return</code> statements which do not explicitly return anything.</li>
<li>Lookups of non-existent properties.</li>
<li>Function parameters which do not had any explicit value passed.</li>
<li>Anything that has been set to the value of <code>undefined</code>.</li>
</ul>

</div><div><h3>Handling changes to the value of <code>undefined</code></h3>

<p>Since the global variable <code>undefined</code> only holds a copy of the actual <em>value</em> of 
<code>undefined</code>, assigning a new value to it does <strong>not</strong> change the value of the 
<em>type</em> <code>undefined</code>.</p>

<p>Still, in order to compare something against the value of <code>undefined</code> it is
necessary to retrieve the value of <code>undefined</code> first.</p>

<p>In order to protect code against a possible overwritten <code>undefined</code> variable, a 
common technique used is to add an additional parameter to an
<a href="#function.scopes">anonymous wrapper</a>, that gets no argument passed to it.</p>

<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // undefined in the local scope does 
    // now again refer to the value

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>Another way to achieve the same effect would be to use a declaration inside the 
wrapper.</p>

<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>The only difference being here, that this version results in 4 more bytes being
used in case it is minified and there is no other <code>var</code> statement inside the
anonymous wrapper.</p>

</div><div><h3>Uses of <code>null</code></h3>

<p>While <code>undefined</code> in the context of the JavaScript language is mostly used in
the sense of a traditional <em>null</em>, the actual <code>null</code> (both a literal and a type)
is more or less just another data type.</p>

<p>It is used in some JavaScript internals (like declaring the end of the
prototype chain by setting <code>Foo.prototype = null</code>), but in almost all cases it
can be replaced by <code>undefined</code>.</p></div></article><article id="core.semicolon"><h2>Automatic semicolon insertion</h2><div><p>Although JavaScript has C style syntax, it does <strong>not</strong> enforce the use of
semicolons in the source code, it is possible to omit them.</p>

<p>But JavaScript is not a semicolon-less language, it in fact needs the 
semicolons in order to understand the source code. Therefore the JavaScript
parser <strong>automatically</strong> inserts them whenever it encounters a parse
error due to a missing semicolon.</p>

<pre><code>var foo = function() {
} // parse error, semicolon expected
test()
</code></pre>

<p>Insertion happens, and the parser tries again.</p>

<pre><code>var foo = function() {
}; // no error, parser continues
test()
</code></pre>

<p>The automatic insertion of semicolon is considered to be one of <strong>biggest</strong>
design flaws in the language, as it <em>can</em> change the behavior of code.</p>

</div><div><h3>How it works</h3>

<p>The code below has no semicolons in it, so it is up to the parser to decide where
to insert them.</p>

<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)
</code></pre>

<p>Below is the result of the parser&#39;s "guessing" game.</p>

<pre><code>(function(window, undefined) {
    function test(options) {

        // Not inserted, lines got merged
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- inserted

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- inserted

        return; // &lt;- inserted, breaks the return statement
        { // treated as a block

            // a label and a single expression statement
            foo: function() {} 
        }; // &lt;- inserted
    }
    window.test = test; // &lt;- inserted

// The lines got merged again
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- inserted

})(window); //&lt;- inserted
</code></pre>

<aside>
  <p><strong>Note:</strong> The JavaScript parser does not "correctly" handle return statements 
  which are followed by a new line, while this is not neccessarily the fault of 
  the automatic semicolon insertion, it can still be an unwanted side-effect. </p>
</aside>

<p>The parser drastically changed the behavior of the code above, in certain cases
it does the <strong>wrong thing</strong>.</p>

</div><div><h3>Leading parenthesis</h3>

<p>In case of a leading parenthesis, the parser will <strong>not</strong> insert a semicolon.</p>

<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})
</code></pre>

<p>This code gets transformed into one line.</p>

<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})
</code></pre>

<p>Chances are <strong>very</strong> high that <code>log</code> does <strong>not</strong> return a function; therefore,
the above will yield a <code>TypeError</code> stating that <code>undefined is not a function</code>.</p>

</div><div><h3>In conclusion</h3>

<p>It is highly recommended to <strong>never</strong> omit semicolons, it is also advocated to 
keep braces on the same line with their corresponding statements and to never omit 
them for one single-line <code>if</code> / <code>else</code> statements. Both of these measures will 
not only improve the consistency of the code, they will also prevent the 
JavaScript parser from changing its behavior.</p></div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Other</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> and <code>setInterval</code></h2><div><p>Since JavaScript is asynchronous, it is possible to schedule the execution of a 
function by using the <code>setTimeout</code> and <code>setInterval</code> functions.</p>

<aside>
  <p><strong>Note:</strong> Timeouts are <strong>not</strong> part of the ECMAScript Standard, they are
  implemented as part of the <a href="http://en.wikipedia.org/wiki/Document_Object_Model">DOM</a>.</p>
</aside>

<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // returns a Number &gt; 0
</code></pre>

<p>When <code>setTimeout</code> gets called, it will return the ID of the timeout and schedule
<code>foo</code> to run in <strong>approximately</strong> one thousand milliseconds in the future. 
<code>foo</code> will then get executed exactly <strong>once</strong>.</p>

<p>Depending on the timer resolution of the JavaScript engine that is running the 
code, as well as the fact that JavaScript is single threaded and other code that 
gets executed might block the thread, it is by <strong>no means</strong> a safe bet that one 
will get the exact delay that was specified in the <code>setTimeout</code> call.</p>

<p>The function that was passed as the first parameter will get called by the
<em>global object</em>, that means, that <a href="#function.this"><code>this</code></a> inside the called function 
refers to that very object.</p>

<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this refers to the global object
        console.log(this.value); // will log undefined
    };
    setTimeout(this.method, 500);
}
new Foo();
</code></pre>

<aside>
  <p><strong>Note:</strong> As <code>setTimeout</code> takes a <strong>function object</strong> as its first parameter, an
  often made mistake is to use <code>setTimeout(foo(), 1000)</code>, which will use the 
  <strong>return value</strong> of the call <code>foo</code> and <strong>not</strong> <code>foo</code>. This is, most of the time, 
  a silent error, since when the function returns <code>undefined</code> <code>setTimeout</code> will 
  <strong>not</strong> raise any error.</p>
</aside>

</div><div><h3>Stacking calls with <code>setInterval</code></h3>

<p>While <code>setTimeout</code> only runs the function once, <code>setInterval</code> - as the name 
suggests - will execute the function <strong>every</strong> <code>X</code> milliseconds. But its use is 
discouraged. </p>

<p>When code that is being executed blocks the timeout call, <code>setInterval</code> will 
still issue more calls to the specified function. This can, especially with small
intervals, result in function calls stacking up.</p>

<pre><code>function foo(){
    // something that blocks for 1 second
}
setInterval(foo, 100);
</code></pre>

<p>In the above code <code>foo</code> will get called once and will then block for one second.</p>

<p>While <code>foo</code> blocks the code <code>setInterval</code> will still schedule further calls to
it. Now, when <code>foo</code> has finished, there will already be <strong>ten</strong> further calls to
it waiting for execution.</p>

</div><div><h3>Dealing with possible blocking code</h3>

<p>The easiest as well as most controllable solution, is to use <code>setTimeout</code> within
the function itself.</p>

<pre><code>function foo(){
    // something that blocks for 1 second
    setTimeout(foo, 100);
}
foo();
</code></pre>

<p>Not only does this encapsulate the <code>setTimeout</code> call, but it also prevents the
stacking of calls and it gives additional control.<code>foo</code> itself can now decide 
whether it wants to run again or not.</p>

</div><div><h3>Manually clearing timeouts</h3>

<p>Clearing timeouts and intervals works by passing the respective ID to
<code>clearTimeout</code> or <code>clearInterval</code>, depending which <code>set</code> function was used in
the first place.</p>

<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);
</code></pre>

</div><div><h3>Clearing all timeouts</h3>

<p>As there is no built-in method for clearing all timeouts and/or intervals, 
it is necessary to use brute force in order to achieve this functionality.</p>

<pre><code>// clear "all" timeouts
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}
</code></pre>

<p>There might still be timeouts that are unaffected by this arbitrary number;
therefore, is is instead recommended to keep track of all the timeout IDs, so
they can be cleared specifically.</p>

</div><div><h3>Hidden use of <code>eval</code></h3>

<p><code>setTimeout</code> and <code>setInterval</code> can also take a string as their first parameter.
This feature should <strong>never</strong> be used, since it internally makes use of <code>eval</code>.</p>

<aside>
  <p><strong>Note:</strong> Since the timeout functions are <strong>not</strong> specified by the ECMAScript
  standard, the exact workings when a string is passed to them might differ in
  various JavaScript implementations. As a fact, Microsoft&#39;s JScript makes use of
  the <code>Function</code> constructor in place of <code>eval</code>.</p>
</aside>

<pre><code>function foo() {
    // will get called
}

function bar() {
    function foo() {
        // never gets called
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();
</code></pre>

<p>Since <code>eval</code> is not getting called <a href="#core.eval">directly</a> in this case, the string 
passed to <code>setTimeout</code> will get executed in the <em>global scope</em>; thus, it will 
not use the local variable <code>foo</code> from the scope of <code>bar</code>.</p>

<p>It is further recommended to <strong>not</strong> use a string for passing arguments to the
function that will get called by either of the timeout functions. </p>

<pre><code>function foo(a, b, c) {}

// NEVER use this
setTimeout(&#39;foo(1,2, 3)&#39;, 1000)

// Instead use an anonymous function
setTimeout(function() {
    foo(a, b, c);
}, 1000)
</code></pre>

<aside>
  <p><strong>Note:</strong> While it is also possible to use the syntax 
  <code>setTimeout(foo, 1000, a, b, c)</code>, it is not recommended, as its use may lead
  to subtle errors when used with <a href="#function.this">methods</a>.</p>
</aside>

</div><div><h3>In conclusion</h3>

<p><strong>Never</strong> should a string be used as the parameter of <code>setTimeout</code> or 
<code>setInterval</code>. It is a clear sign of <strong>really</strong> bad code, when arguments need 
to be supplied to the function that gets called. An <em>anonymous function</em> should
be passed that then takes care of the actual call.</p>

<p>Further, the use of <code>setInterval</code> should be avoided since its scheduler is not
blocked by executing JavaScript.</p></div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with 
<a href="http://nodejs.org/">Node.js</a>using a
<a href="https://github.com/visionmedia/jade/">jade</a>template.
</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script><script src="javascript/prettify.js"></script><script src="javascript/plugin.js"></script><script src="javascript/garden.js"></script></body></html>