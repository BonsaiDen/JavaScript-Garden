<!DOCTYPE html><html lang="pl"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="Przewodnik po dziwactwach i wadach języka JavaScript."><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]-->
</head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha suomeksi">fi</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript Garden 中文翻译">zh</a></li><li class="active"><a href="/JavaScript-Garden/pl" title="JavaScript Garden - ogród JavaScript po polsku">pl</a></li><li><a href="/JavaScript-Garden/" title="JavaScript Garden in English">en</a></li><li><a href="/JavaScript-Garden/ru" title="JavaScript Гарден по-русски">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden Türkçe">tr</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Wstęp</a></h1><ul><li><a href="#intro.authors">Autorzy</a></li><li><a href="#intro.contributors">Kontrybutorzy</a></li><li><a href="#intro.translators">Tłumaczenie</a></li><li><a href="#intro.hosting">Hosting</a></li><li><a href="#intro.license">Licencja</a></li></ul></li><li class="nav_object"><h1><a href="#object">Obiekty</a></h1><ul><li><a href="#object.general">Wykorzystanie obiektów i ich właściwości</a></li><li><a href="#object.prototype">Prototyp</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">Pętla <code>for in</code></a></li></ul></li><li class="nav_function"><h1><a href="#function">Funkcje</a></h1><ul><li><a href="#function.general">Deklaracje funkcji i wyrażenia funkcyjne</a></li><li><a href="#function.this">Jak działa <code>this</code></a></li><li><a href="#function.closures">Domknięcia i referencje</a></li><li><a href="#function.arguments">Obiekt <code>arguments</code></a></li><li><a href="#function.constructors">Konstruktory</a></li><li><a href="#function.scopes">Zasięg zmiennych i przestrzenie nazw</a></li></ul></li><li class="nav_array"><h1><a href="#array">Tablice</a></h1><ul><li><a href="#array.general">Iterowanie po tablicach oraz właściwościach tablic</a></li><li><a href="#array.constructor">Konstruktor <code>Array</code></a></li></ul></li><li class="nav_types"><h1><a href="#types">Typy</a></h1><ul><li><a href="#types.equality">Równość i porównania</a></li><li><a href="#types.typeof">Operator <code>typeof</code></a></li><li><a href="#types.instanceof">Operator <code>instanceof</code></a></li><li><a href="#types.casting">Rzutowanie typów</a></li></ul></li><li class="nav_core"><h1><a href="#core">Jądro</a></h1><ul><li><a href="#core.eval">Dlaczego nie należy używać <code>eval</code>?</a></li><li><a href="#core.undefined"><code>undefined</code> i <code>null</code></a></li><li><a href="#core.semicolon">Automatyczne wstawianie średnika</a></li></ul></li><li class="nav_other"><h1><a href="#other">Inne</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> i <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Wstęp</h1><div><p><strong>JavaScript Garden</strong> jest rosnącą kolekcją dokumentów o najdziwniejszych 
częściach języka JavaScript. Dokumentacja pomaga uniknąć najczęściej popełnianych
błędów, sybtelnych bugów, problemów wydajnościowych oraz złych praktyk, na które
niedoświadczeni programiści JavaScript mogą natrafić próbując poznać tajniki tego 
języka.</p>

<p>JavaScript Garden <strong>nie</strong> ma na celu nauczyć Cię języka JavaScript. Podstawowa
wiedza na temat języka jest wymagana do zrozumienia zagadnień poruszanych w tym 
przewodniku. Aby nauczyć się podstaw jezyka JavaScript, odwiedź znakomity 
<a href="https://developer.mozilla.org/en/JavaScript/Guide">przewodnik</a> na stronach Mozilla Developer Network.</p></div></header><!-- Articles--><article id="intro.authors"><h2>Autorzy</h2><div><p>Ten przewodnik jest dziełem dwóch uroczych użytkowników <a href="http://stackoverflow.com/">Stack Overflow</a>,
<a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a> (Treść) oraz <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Projekt).</p></div></article><article id="intro.contributors"><h2>Kontrybutorzy</h2><div><ul>
<li><a href="https://github.com/caio">Caio Romão</a> (Poprawki pisowni)</li>
<li><a href="https://github.com/blixt">Andreas Blixt</a> (Poprawki językowe)</li>
</ul></div></article><article id="intro.translators"><h2>Tłumaczenie</h2><div><ul>
<li><a href="http://qfel13.pl">Łukasz Kufel</a></li>
<li><a href="http://blog.ciemborowicz.pl">Maciej Ciemborowicz</a></li>
</ul></div></article><article id="intro.hosting"><h2>Hosting</h2><div><p>JavaScript Garden znajduje się na serwerach GitHub, ale dzięki wsparciu 
<a href="http://cramerdev.com/">Cramer Rozwoju</a> posiadamy mirror na serwerze <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p></div></article><article id="intro.license"><h2>Licencja</h2><div><p>JavaScript Garden jest publikowany w ramach <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">licencji MIT</a> i kod źródłowy znajduje 
się na serwerze <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. Jeśli znajdziesz jakieś błędy lub literówek zgłoś proszę 
<a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">problem</a> lub rozwiąż go i zgloś pull request ze swojego repozytorium. 
Możesz nas także znaleźć w pokoju <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavaScript</a> na chacie Stack Overflow. </p></div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Obiekty</h1></header><!-- Articles--><article id="object.general"><h2>Wykorzystanie obiektów i ich właściwości</h2><div><p>Wszystko w JavaScripcie zachowuje sie jak obiekt, z dwoma wyjątkami
<a href="#core.undefined"><code>null</code></a> oraz <a href="#core.undefined"><code>undefined</code></a>. </p>

<pre><code>false.toString() // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1
</code></pre>

<p>Popularnym błędem jest traktowanie literałów liczbowych jak obiektu.
Spowodowane jest to specyfiką parsera JavaScript, który interpretuje kropkę
po literale liczbowym jako rozdzielenie części całkowitej od części ułamkowej 
liczby.</p>

<pre><code>2.toString(); // wyrzuca błąd SyntaxError
</code></pre>

<p>Istnieje kilka rozwiązań, dzieki którym literał liczbowy będzie zachowywał się 
jak obiekt.</p>

<pre><code>2..toString(); // druga kropka jest poprawnie rozpoznana
2 .toString(); // zauważ, że pozostawiona jest spacja przed kropką
(2).toString(); // 2 zostanie najpierw zewaluowane
</code></pre>

</div><div><h3>Obiekty jako typy danych</h3>

<p>Obiekty w języku JavaScript mogą być używana jako <a href="http://pl.wikipedia.org/wiki/Tablica_asocjacyjna"><em>tablice asocjacyjne</em></a>, 
ponieważ obiekty składają się głównie z mapowań pomiędzy nazwanymi właściwościami (kluczami)
a wartościami dla tych atrybutów.</p>

<p>Używając literału obiektu - notacji <code>{}</code> - istnieje możliwość stworzenia obiektu prostego.
Ten nowy obiekt bedzie <a href="#object.prototype">dziedziczył</a> z <code>Object.prototype</code> oraz 
nie bedzie posiadał żadnych <a href="#object.hasownproperty">własnych właściwości</a>.</p>

<pre><code>var foo = {}; // nowy, pusty obiekt

// nowy obiekt z właściwością test o wartości 12
var bar = {test: 12}; 
</code></pre>

</div><div><h3>Dostęp do właściwości</h3>

<p>Właściwości obiektu można uzyskać na dwa sposoby - poprzez notację z kropką
lub z nawiasami kwadratowymi.</p>

<pre><code>var foo = {name: &#39;Kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // wyrzuca błąd SyntaxError
foo[&#39;1234&#39;]; // działa, zwraca undefined
</code></pre>

<p>Obie notacje są identyczne w swoim działaniu, z tą tylko różnicą, że notacja z nawiasami 
kwadratowymi pozwala na dynamiczne dodawanie właściwości i nie prowadzi do wyrzucenia
błędu podczas odczytu nieistniejącej właściwości.</p>

</div><div><h3>Usuwanie właściwości</h3>

<p>Jedynym sposobem na faktycze usunięcie własności z obiektu jest użycie operatora 
<code>delete</code>. Ustawienie własności na <code>undefined</code> lub <code>null</code> usunie tylko <em>wartość</em> 
związaną z własnością, ale nie usunie to <em>klucza</em> (nazwy własności) z obiektu.</p>

<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}
</code></pre>

<p>Powyższy kod wypisuje dwie linie - <code>bar undefined</code> i <code>foo null</code>. Tylko własność <code>baz</code>
została usunięta i dlatego nie została wypisana.</p>

</div><div><h3>Notacja właściwości</h3>

<pre><code>var test = {
    &#39;case&#39;: &#39;jestem zastrzeżonym słowem kluczowym, więc muszę być w cudzysłowie&#39;,
    delete: &#39;tak samo jak ja&#39; // wyrzuca błąd SyntaxError
};
</code></pre>

<p>Nazwy właściwości obiektu mogą być zarówno zapisane jako tekst (bez cudzysłowów 
lub apostrofów) lub jako string (w cudzisłowach lub apostrofach). 
Ze względu na kolejne niedociągnięcie w parserze JavaScript,
powyższy kod wyrzuci błąd <code>SyntaxError</code> dla implementacji JavaScript ponizej ECMAScript 5.</p>

<p>Ten błąd wynika z faktu, że <code>delete</code> jest <em>słowem kluczowym</em>, dlatego musi zostać 
zapisany jako <em>string</em> (z cudzysłowami lub apostrofami), aby zapewnić, że zostanie 
to poprawnie zinterpretowane przez starsze silniki języka JavaScript.</p></div></article><article id="object.prototype"><h2>Prototyp</h2><div><p>JavaScript nie posiada klasycznego modelu dziedziczenia. Zamiast tego 
dziedziczenie jest realizowane poprzez <em>prototypy</em>.</p>

<p>Choć jest to często uważane za jedną ze słabości języka JavaScript,
prototypowy model dziedziczenia, jest w rzeczywistości potężniejszy od klasycznego
modelu. Na przykład stworzenia klasycznego modelu na podstawie modelu prototypowego 
jest dość proste, podczas gdy zrobienie odwrotnego przekształcenie to o wiele trudniejsze zadanie.</p>

<p>Ze względu na fakt, że w JavaScript jest w zasadzie jedynym powszechnie stosowanym 
językiem, któy posiada prototypowy model dziedziczenia, dostosowanie się do różnic pomiędzy
tymi dwoma modelami wymaga trochę czasu. </p>

<p>Pierwszą znaczącą różnicą jest to, że dziedziczenie w JavaScript odbywa się za pomocą
tak zwanych <em>łańcuchów prototypów</em>.</p>

<aside>
  <p><strong>Uwaga:</strong> Używanie po prostu <code>Bar.prototype = Foo.prototype</code> spowoduje, że oba obiekty 
  będą korzystały z <strong>tego samego</strong> prototypu. W związku z tym zmiany w prototypie jednego
  obiektu będą również zmieniały prototyp drugiego obiektu, co jest ,w wiekszości przypadków, 
  niepożądanym efektem.</p>
</aside>

<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Ustawienie prototypu Bar na nową instancję Foo
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Upewniamy się, że Bar jest ustawiony jako rzeczywisty konstruktor
Bar.prototype.constructor = Bar;

var test = new Bar() // tworzymy nową instancję Bar

// The resulting prototype chain
test [instance of Bar]
    Bar.prototype [instance of Foo] 
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* etc. */ }
</code></pre>

<p>W powyższym przykładzie obiekt <code>test</code> będzie dziedziczył z obydwu, tj. 
<code>Bar.prototyp</code> i <code>Foo.prototyp</code>, stąd będzie miał dostęp do funkcji <code>method</code>,
która była zdefiniowana w <code>Foo</code>. Ponadto obiekt będzie miał dostęp do 
właściwości <code>value</code>, która jest jednyną instancją <code>Foo</code> i stała się jego prototypem.
Należy pamiętać, że <code>new Bar</code> <strong>nie</strong> tworzy nowej instancji <code>Foo</code>, 
tylko wykorzystuje instancję, która jest przypisana do własności <code>prototype</code>. 
Zatem Wszystkie instancje <code>Bar</code> będą dzieliły tą samą własność <code>value</code>.</p>

<aside>
  <p><strong>Uwaga:</strong> <strong>Nie</strong> należy używać konstrukcji <code>Bar.prototype = Foo</code>, 
  ponieważ nie spowoduje ona przypisania prototypu <code>Foo</code> tylko obiektu 
  funckji <code>Foo</code>. Zatem łańcuch prototypów nie bedzie zawierał <code>Foo.prototype</code>,
  tylko <code>Function.prototype</code>, więc metoda <code>method</code> nie będzie w łańcuchu prototypów. </p>
</aside>

</div><div><h3>Wyszukiwanie własności</h3>

<p>Podczas dostępu do właściwości obiektu JavaScript przejdzie w górę łańcucha 
prototypów, dopóki nie znajdzie właściwości bez nazwy.</p>

<p>Gdy przeszukiwanie dotrze do końca (szczytu) łańcucha, mianowicie <code>Object.prototype</code> 
i nadal nie znajdzie określonej właściwości, to zwróci wartość 
<a href="#core.undefined">undefined</a>.    </p>

</div><div><h3>Właściwość prototype</h3>

<p>Podczas gdy właściwość <code>prototype</code> jest używana przez język do budowania łańcucha 
prototypów, istnieje możliwość przypisania do niej <strong>dowolnej</strong> wartości. Jednakże
prymitywne typy będą po prostu ignorowanie, jeżeli zostaną ustawione jako <code>prototype</code>.</p>

<pre><code>function Foo() {}
Foo.prototype = 1; // nie ma wpływu
</code></pre>

<p>Przypisywanie obiektów, jak pokazano w powyższym przykładzie, zadziała i pozwala 
na dynamiczne tworzenie łańcuchów prototypów.</p>

</div><div><h3>Wydajność</h3>

<p>Czas wyszukiwania właściwości, które są na końcu łańcucha prototypów może mieć 
negatywny wpływ na wydajność krytycznych części kodu. Dodatkowo, próba dostępu 
do nieistniejącej właściwości zawsze spowoduje przeszukanie całego łańcucha prototypów.</p>

<p>Również podczas <a href="#object.forinloop">iteracji</a> po właściwościach obiektu
<strong>każda</strong> właściwość, która znajduje się w łańcuchu prototypów (niezależnie 
na jakim znajduje się poziomie) zostanie wyliczona.</p>

</div><div><h3>Rozszerzanie natywnych prototypów</h3>

<p>Rozszerzanie <code>Object.prototype</code> lub innego prototypu wbudowanych typów jest jednym z 
najczęściej nadużywanej częsci języka JavaScript.</p>

<p>Technika ta nazywana jest <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> i łamie zasady <em>enkapsulacji</em>.
Mimo to jest szeroko rozpowszechniona w frameworkach takich jak <a href="http://prototypejs.org/">Prototype</a>.
Nie ma jednak dobrego powodu, aby zaśmiecać wbudowane typy poprzez wzbogacanie ich o 
<em>niestandardowe</em> funkcjonalności.</p>

<p><strong>Jedynym</strong> dobrym powodem do rozszerzania wbudowanych prototypów jest portowanie <br />
funkcjonalności znajdujących sie w nowszych silnikach JavaScript, np. <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a></p>

</div><div><h3>Wnioski</h3>

<p>Zanim przystąpi się do pisania skomplikowanego kodu korzystającego z dziedziczania, <br />
należy <strong>całkowicie</strong> zrozumieć prototypowy model dziedziczenia. Ponadto trzeba uważać 
na długość łańcucha prototypów i w razie potrzeby zmniejszać ilość dziedziczeń, 
aby uniknąć problemów z wydajnością. Natywne prototypy <strong>nigdy</strong> nie powinny być 
rozszerzane, chyba że ze względu na wprowadzanie kompatybilności z nowszymi silnikami 
JavaScript.</p></div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>W celu sprawdzenia, czy dana właściwość została zdefiniowana <em>w tym</em> obiekcie, a <strong>nie</strong> 
w <a href="#object.prototype">łańcuchu prototypów</a>, niezbędne jest skorzystanie z metody 
<code>hasOwnProperty</code>, której wszystkie obiekty dziedziczą z <code>Object.prototype</code>.</p>

<aside>
  <p><strong>Uwaga:</strong> <strong>Nie</strong> wystarczy sprawdzić, czy właściwość jest <code>undefined</code>,
  ponieważ właściwość może istnieć, ale jej wartość być ustawiona na <code>undefined</code>. </p>
</aside>

<p><code>hasOwnProperty</code> jest jedyną metodą w języku JavaScript, która operuje na właściwościach 
i <strong>nie</strong> przegląda całego łańcucha prototypów. </p>

<pre><code>// Zatrucie Object.prototype
Object.prototype.bar = 1; 
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true
</code></pre>

<p>Tylko <code>hasOwnProperty</code> da prawidłowy i oczekiwany rezultat. Jest to istotne podczas 
iteracji po właściwościach obiektu. <strong>Nie</strong> ma innego sposobu na ominięcie
właściwości, która nie została zdefiniowana przez ten <strong>konkretny</strong> obiekt, 
ale gdzieś indziej w łańcuchu prototypów. </p>

</div><div><h3><code>hasOwnProperty</code> jako właściwość</h3>

<p>JavaScript <strong>nie</strong> chroni właściwości o nazwie <code>hasOwnProperty</code>, zatem istnieje 
możliwość, że obiekt będzie posiadać tak nazwaną właściwość. Konieczne jest użycie
<em>zewnętrznego</em> <code>hasOwnProperty</code>, aby otrzymać poprawne rezultaty.</p>

<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // zawsze zwraca false

// Została użyta metoda innego obiektu i wywołana z konkekstem 
// `this` ustawionym na foo
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true
</code></pre>

</div><div><h3>Wnioski</h3>

<p><strong>Jedyną</strong> metodą służącą do sprawdzenia istnienia jakiejś właściwości w konkretnym 
obiekcie jest metoda <code>hasOwnProperty</code>. Zaleca się korzystać z <code>hasOwnProperty</code> w 
<strong>każdej</strong> <a href="#object.forinloop">pętli <code>for in</code></a>. Pozwoli to uniknąć błędów pochodzących 
z rozszerzonych natywnych <a href="#object.prototype">prototypów</a>.</p></div></article><article id="object.forinloop"><h2>Pętla <code>for in</code></h2><div><p>Podobnie jak operator <code>in</code>, pętla <code>for in</code> przeszukuje łańcuch prototypów 
podczas iteracji po właściwościach obiektu.</p>

<aside>
  <p><strong>Uwaga:</strong> pętla <code>for in</code> <strong>nie</strong> będzie iterować po właściwościach, które
  mają ustawiony atrybut <code>enumerable</code> na <code>false</code> (na przykład właściwość 
  <code>length</code> tablicy).</p>
</aside>

<pre><code>// Zatrucie Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // wyświetla obie właściwości: bar i moo
}
</code></pre>

<p>Ponieważ zmiana zachowania pętli <code>for in</code> nie jest możliwa, niezbędne 
jest odfiltrowanie niechcianych właściwości wewnątrz ciała pętli, korzystając 
z metody <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> z <code>Object.prototype</code>.</p>

<aside>
  <p><strong>Uwaga:</strong> Ponieważ pętla <code>for in</code> zawsze przeszukuje cały łańcuch prototypów, 
  będzie się ona stawała coraz wolniejsza przy dodaniu każdej kolejnej warstwy 
  dziedziczenia do obiektu. </p>
</aside>

</div><div><h3>Filtrowania przy użyciu <code>hasOwnProperty</code></h3>

<pre><code>// foo z przykładu powyżej
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}
</code></pre>

<p>To jest jedyna poprawna wersja, której należy używać. Ze względu na użycie 
<code>hasOwnProperty</code> zostanie wypisane <strong>jedynie</strong> <code>moo</code>. Gdy opuścimy <code>hasOwnProperty</code>, 
kod będzie podatny na błędy, gdy natywne prototypy (np. <code>Object.prototype</code>) 
zostaną rozszerzone.</p>

<p><a href="http://www.prototypejs.org/">Prototype</a> jest jednym z popularniejszych frameworków, które dokonują 
takiego rozszerzenia. Używanie tego frameworku oraz nie stosowanie w pętli <code>for in</code> 
metody <code>hasOwnProperty</code> gwarantuje błędy w wykonaniu.</p>

</div><div><h3>Wnioski</h3>

<p>Zaleca się, aby zawsze używać metody <code>hasOwnProperty</code>. Nigdy nie powinno się dokonywać
żadnych założeń na temat środowiska, w którym kod będzie wykonywany ani tego, czy 
natywne prototypy zostały rozszerzone, czy nie.</p></div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Funkcje</h1></header><!-- Articles--><article id="function.general"><h2>Deklaracje funkcji i wyrażenia funkcyjne</h2><div><p>Funcje w języku JavaScript są <a href="http://pl.wikipedia.org/wiki/Typ_pierwszoklasowy">typami pierwszoklasowymi</a>, co oznacza, że mogą 
być przekazywane jak każda inna wartość. Jednym z typowych zastosowań tej cechy 
jest przekazywanie <em>anonimowej funkcji</em> jako callback do innej, prawdopodobnie 
asynchronicznej funkcji.</p>

</div><div><h3>Deklaracja funckcji</h3>

<pre><code>function foo() {}
</code></pre>

<p>Powyższa funkcja zostaje <a href="#function.scopes">wyniesiona</a> zanim program wystartuje. Dzięki temu 
jest dostępna <em>wszędzie</em> w ramach zasięgu, w którym została <em>zadeklarowana</em>,
nawet, jeżeli ta funkcja została wywołana przed faktyczną definicją w kodzie źródłowym.</p>

<pre><code>foo(); // Działa ponieważ definicja funkcji została wyniesiona 
       // na początek zasięgu przed uruchomieniem kodu
function foo() {}
</code></pre>

</div><div><h3>Wyrażenie funkcyjne</h3>

<pre><code>var foo = function() {};
</code></pre>

<p>Ten przykład przypisuje nienazwaną i <em>anonimową</em> funkcję do zmiennej <code>foo</code>.  </p>

<pre><code>foo; // &#39;undefined&#39;
foo(); // wyrzuca błąd TypeError
var foo = function() {};
</code></pre>

<p>Ze względu na fakt, że deklaracja <code>var</code> wynosi zmienną <code>foo</code> na początek zasięgu 
zanim kod faktycznie zostanie uruchomiony, <code>foo</code> będzie zdefiniowane kiedy skrypt 
będzie wykonywany.</p>

<p>Ale ponieważ przypisania robione są dopiero podczas wykonania, wartość <code>foo</code> będzie 
ustawiona na domyślną wartość <a href="#core.undefined">undefined</a> zanim powyższy kod 
zostanie uruchomiony.</p>

</div><div><h3>Nazwane wyrażenia funkcyjne</h3>

<p>Kolejnym specjalnym przypadkiem jest przypisanie nazwanej funkcji. </p>

<pre><code>var foo = function bar() {
    bar(); // Działa
}
bar(); // wyrzuca ReferenceError
</code></pre>

<p>W zewnętrznym zakresie <code>bar</code> nie będzie dostępna, ponieważ funkcja zostaje 
przypisana do <code>foo</code>, jednakże w wewnętrznym zakresie <code>bar</code> będzie dostępna.
Jest to spowodowane tym, jak działa <a href="#function.scopes">rozwiązywanie nazw</a> 
w języku JavaScript. Nazwa funkcji jest <em>zawsze</em> dostępna w lokalnym 
zakresie tej funkcji.</p></div></article><article id="function.this"><h2>Jak działa <code>this</code></h2><div><p>JavaScript posiada inną koncepcję odnośnie tego na co wskazuje słowo kluczowe 
<code>this</code>, niż większość innych języków programowania. Istnieje dokładnie 
<strong>pięć</strong> różnych sytuacji, w których wartość <code>this</code> jest przypisana w języku JavaScript.</p>

<p>JavaScript has a different concept of what the special name <code>this</code> refers to 
than most other programming languages do. There are exactly <strong>five</strong> different 
ways in which the value of <code>this</code> can be bound in the language.</p>

</div><div><h3>Zasięg globalny</h3>

<pre><code>this;
</code></pre>

<p>Używanie <code>this</code> w globalnym zasięgu, zwróci po prostu referencję do obiektu <em>global</em>.</p>

</div><div><h3>Wywołanie funkcji</h3>

<pre><code>foo();
</code></pre>

<p>Tutaj <code>this</code> również będzie wkazywało na obiekt <em>global</em></p>

<aside>
  <p><strong>Uwaga ES5:</strong> W trybie strict mode, przypadki z globalnym zasięgiem nie mają miejsca.
  W tym przypadku <code>this</code> zwróci <code>undefined</code> zamiast wartości.</p>
</aside>

</div><div><h3>Wywoływanie metody</h3>

<pre><code>test.foo(); 
</code></pre>

<p>W tym przypadku <code>this</code> będzie wskazywało na <code>test</code>.</p>

</div><div><h3>Wywołanie konstruktora</h3>

<pre><code>new foo(); 
</code></pre>

<p>Wywołanie funkcji, które jest poprzedzone słowem kluczowym <code>new</code>, zachowuje się 
jak <a href="#function.constructors">konstruktor</a>. Wewnątrz funkcji <code>this</code> będzie 
wskazywało na <em>nowo utworzony</em> obiekt.</p>

</div><div><h3>Jawne ustawienie <code>this</code></h3>

<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // tablica zostanie zamieniona w to co poniżej
foo.call(bar, 1, 2, 3); // rezultat a = 1, b = 2, c = 3
</code></pre>

<p>Używając metod <code>call</code> lub <code>apply</code> z prototypu <code>Function.prototype</code>, wartość <code>this</code> 
wewnątrz wołanej funkcji zostanie <strong>jawnie ustawiona</strong> na pierwszy argument przekazany 
podczas wywołania tych metod.</p>

<p>Zatem w powyższym przykładzie przypadek <em>Wywoływanie metody</em> nie będzie miał 
miejsca i <code>this</code> wewnątrz <code>foo</code> będzie wskazywać na <code>bar</code>.</p>

<aside>
  <p><strong>Uwaga:</strong> <code>this</code> <strong>nie może</strong> zostać użyte jako referencja do obiektu wewnątrz literału 
  <code>Object</code>. Zatem <code>var obj = {me: this}</code> <strong>nie</strong> spowoduje, że <code>me</code> będzie wskazywać na <code>obj</code>,
  <code>this</code> zostaje związane z wartością tylko w powyższych pięciu wylistowanych przypadkach.</p>
</aside>

</div><div><h3>Częste pułapki</h3>

<p>Mimo iż Większość z tych przypadków ma sens, to pierwszy przypadek powinien być 
traktorany jako błąd podczas projektowania języka i <strong>nigdy</strong> nie wykorzystywany 
w praktyce.</p>

<pre><code>Foo.method = function() {
    function test() {
        // wewnątrz tej funkcji this wskazuje na obiekt global
    }
    test();
}
</code></pre>

<p>Powszechnym błędem jest myślenie, że <code>this</code> wewnątrz <code>test</code> wskazuje na <code>Foo</code>, 
podczas gdy w rzeczywistości tak <strong>nie jest</strong>.</p>

<p>Aby uzyskać dostęp do <code>Foo</code> wewnątrz <code>test</code>, niezbędne jest stworzenie wewnątrz 
metody lokalnej zmiennej, która będzie wskazywała na <code>Foo</code>.</p>

<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Należy używać that zamiast this wewnątrz tej funkcji
    }
    test();
}
</code></pre>

<p><code>that</code> jest zwykłą zmienną, ale jest to powszechnie stosowana konwencja otrzymywania <br />
wartości zewnętrznego <code>this</code>. W połączeniu z <a href="#function.closures">domknięciami(closures)</a>, 
jest to sposób na przekazywanie wartości <code>this</code> wokół.</p>

</div><div><h3>Metody przypisywania</h3>

<p>Kolejną rzeczą, która <strong>nie</strong> działa w języku JavaScript, jest nadawanie aliasów 
funkcjom, co oznacza <strong>przypisanie</strong> metody do zmiennej.</p>

<pre><code>var test = someObject.methodTest;
test();
</code></pre>

<p>Podobnie jak w pierwszym przypadku <code>test</code> zachowuje się jak wywołanie zwykłej 
funkcji, a zatem wewnątrz funkcji <code>this</code> już nie będzie wskazywało <code>someObject</code>.</p>

<p>Podczas gdy późne wiązanie <code>this</code> może się na początku wydawać złym pomysłem, 
to w rzeczywistości jest to rzecz, która sprawia, że 
<a href="#object.prototype">dziedziczenie prototypowe</a> działa.</p>

<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();
</code></pre>

<p>Kiedy metoda <code>method</code> zostanie wywołana na instancji <code>Bar</code>, <code>this</code> będzie 
wskazywało właśnie tę instancję.</p></div></article><article id="function.closures"><h2>Domknięcia i referencje</h2><div><p>Jedną z najpotężniejszych funkcjonalności języka JavaScript są <em>domknięcia</em>. 
Oznacza to że zasięg <strong>zawsze</strong> posiada dostęp do zewnętrznego zasięgu, w którym 
został zdefiniowany. Ponieważ zasięg w JavaScript można definiować tylko poprzez 
<a href="#function.scopes">funckję</a>, wszystkie funkcje domyślnie zachowują się jak domknięcia.</p>

</div><div><h3>Emulowanie prywatnych zmiennych</h3>

<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5
</code></pre>

<p>Tutaj <code>Counter</code> zwraca <strong>dwa</strong> domknięcia: funkcję <code>increment</code> oraz funkcję <code>get</code>. 
Obie te funkcje trzymają <strong>referencję</strong> do zasięgu <code>Counter</code>, a co za tym idzie 
zawsze posiadają dostęp do zmiennej <code>count</code> tak, jakby ta zmienna była zdefiniowana 
w zasięgu tych funkcji.</p>

</div><div><h3>Dlaczego zmienne prywatne działają?</h3>

<p>Ponieważ nie ma możliwości wskazania lub przypisania zasięgu w JavaScript, 
<strong>nie</strong> istnieje sposób, aby uzyskać dostęp do zmiennej <code>count</code> z zewnątrz. 
Wykorzystanie tych dwóch domknięć jest jedynym sposobem na interakcję z tą zmienną.</p>

<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};
</code></pre>

<p>Powyższy kod <strong>nie</strong> zmieni wartości zmiennej <code>count</code> wewnątrz zasięgu <code>Counter</code>, 
ponieważ <code>foo.hack</code> nie została zadeklarowana wewnątrz <strong>tego konkretnego</strong> zasięgu. 
Zamiast tego funkcja utworzy lub nadpisze <em>globalną</em> zmienną <code>count</code>.</p>

</div><div><h3>Domknięcia wewnątrz pętli</h3>

<p>Jednym z częstrzych błędów jest wykorzystywanie domknięć wewnątrz pętli, 
aby wartość zmiennej po której odbywa się iteracja była kopiowana do 
wewnętrznej funkcji.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}
</code></pre>

<p>Powyższy kod <strong>nie</strong> wypisze numerów od <code>0</code> do <code>9</code>, ale wypisze 
dziesięć razy liczbę <code>10</code>.</p>

<p><em>Anonimowa</em> funkcja trzyma <strong>wskaźnik</strong> do zmiennej <code>i</code> i podczas uruchomienia 
<code>console.log</code>, pętla <code>for</code> już zakończyła działanie i wartość zmiennej <code>i</code> 
została ustawiona na <code>10</code>.</p>

<p>Aby otrzymać zamierzony efekt, niezbędne jest <strong>skopiowanie</strong> wartości 
zmiennej <code>i</code>.</p>

</div><div><h3>Unikanie problemu z referencją</h3>

<p>Aby skopiować wartość zmiennej, po której iterujemy w pętli, należy skorzystać 
z <a href="#function.scopes">anonimowego wrappera</a>.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}
</code></pre>

<p>Zewnętrzna anonimowa funkcja zostanie wywołana od razu z parametrem <code>i</code> 
jako pierwszym argumentem oraz otrzyma kopię <strong>wartości</strong> zmiennej <code>i</code> jako 
zmienną <code>e</code>.</p>

<p>Anonimowa funkcja która zostaje przekazana do <code>setTimeout</code> teraz posiada 
referencję do zmiennej <code>e</code>, która nie zostanie zmieniona przez pętle <code>for</code>.</p>

<p>Istnieje jeszcze jeden sposób na osiągnięcie tego samego efektu. Należy zwrócic 
fukcję z anonimowego wrappera, wówczas kod będzie zachowywał się jak ten 
wcześniejszy.</p>

<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}
</code></pre></div></article><article id="function.arguments"><h2>Obiekt <code>arguments</code></h2><div><p>Każdy zasięg funkcyjny w języku JavaScript ma dostęp do specjalnej zmiennej <code>arguments</code>. 
Ta zmienna trzyma listę wszystkich argumentów przekazanych do funkcji.</p>

<aside>
  <p><strong>Uwaga:</strong> W przypadku gdy <code>arguments</code> zostanie zadeklarowana wewnątrz funkcji
  poprzez <code>var</code> lub jako nazwa jednego z formalnych parametrów, obiekt <code>arguments</code> 
  nie zostanie utworzony.</p>
</aside>

<p>Obiekt <code>arguments</code> <strong>nie</strong> jest typu <code>Array</code>. Mimo że posiada pewne cechy 
semantyki tablic - właściwość <code>length</code> - to w rzeczywistości nie dziedziczy 
on z <code>Array.prototype</code>, tylko z <code>Object</code>.</p>

<p>Ze względu na to, na obiekcie <code>arguments</code> <strong>nie</strong> można używać standardowych dla tablic metod, 
takich jak <code>push</code>, <code>pop</code> czy <code>slice</code>. Mimo że iteracja przy pomocy 
pętli <code>for</code> działa dobrze, to aby skorzystać ze standardowych metod tablicowych 
należy skonwertować <code>arguments</code> do prawdziwego obiekt <code>Array</code>.</p>

</div><div><h3>Konwersja do tablicy</h3>

<p>Poniższy kod zwróci nowy obiekt <code>Array</code> zawierający wszystkie elementy 
obiektu <code>arguments</code>.</p>

<pre><code>Array.prototype.slice.call(arguments);
</code></pre>

<p>Jednakże konwersja ta jest <strong>wolna</strong> i <strong>nie jest zalecana</strong> w sekcjach, 
które mają duży wpływ na wydajność.</p>

</div><div><h3>Przekazywanie argumentów</h3>

<p>Zalecany sposób przekazywania argumentów z jednej funkcji do następnej 
wyglada następująco:</p>

<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // do stuff here
}
</code></pre>

<p>Kolejną sztuczką jest użycie razem <code>call</code> i <code>apply</code> w celu stworzenia 
szybkich i nieograniczonych wrapperów.  </p>

<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Stworzenie nieograniczoną wersję metody "method" 
// która przyjmuje parametry: this, arg1, arg2...argN
Foo.method = function() {

    // Rezultat: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};
</code></pre>

</div><div><h3>Parametry formalne i indeksy argumentów</h3>

<p>Obiekt <code>arguments</code> tworzy funkcje <em>getter</em> i <em>setter</em> nie tylko dla swoich 
właściwości, ale również dla parametrów formalnych funkcji.</p>

<p>W rezultacie zmiana wartości parametru formalnego zmieni również wartość 
odpowiadającemu mu wpisowi w obiekcie <code>arguments</code>. Zachodzi to również w drugą stronę.</p>

<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2                                                           

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);
</code></pre>

</div><div><h3>Mity i prawdy o wydajności</h3>

<p>Obiekt <code>arguments</code> jest tworzony zawsze, z wyjątkiem dwóch przypadków, gdy
zmienna o takiej nazwie jest zdefiniowana wewnątrz funkcji lub jeden z parametrów 
formalnych funkcji ma taką nazwę. Nie ma znaczenia czy obiekt <code>arguments</code> jest 
używany czy nie.</p>

<p>Zarówno <em>gettery</em> jak i <em>settery</em> są zawsze tworzone, zatem używanie ich nie ma 
praktycznie żadnego wpływu na wydajność. Zwłaszcza w rzeczywistym kodzie, który 
wykorzystuje coś więcej niż tylko prosty dostęp do właściwości obiektu <code>arguments</code>. </p>

<aside>
  <p><strong>Uwaga ES5:</strong> <em>gettery</em> and <em>settery</em> nie są tworzone w trybie strict mode</p>
</aside>

<p>Jednakże, istnieje jeden przypadek w którym wydajność drastycznie spada w 
nowoczesnych silnikach JavaScript. Ten przypadek to wykorzystanie 
<code>arguments.callee</code>.</p>

<pre><code>function foo() {
    arguments.callee; // operowanie na obiekcie funkcji
    arguments.callee.caller; // i obiekcie funkcji wywołującej
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // Normalnie zostałaby wykorzystana metoda inline
    }
}
</code></pre>

<p>W powyższym przykładzie <code>foo</code> nie może zostać wykorzystana metoda <a href="http://en.wikipedia.org/wiki/Inlining">inline</a> 
ponieważ potrzebne są nie tylko informacje na własny temat ale również 
na temat funkcji wywołującej. Takie użycie nie tylko uniemożliwia 
inlining i korzyści z niego wynikające, ale też łamie zasady enkapsulacji, 
ponieważ ta funkcja jest zależna od kontekstu w jakim została wywołana.</p>

<p><strong>Mocno zalecane</strong> jest aby <strong>nigdy</strong> nie korzystać z <code>arguments.callee</code> 
i żadnej jej własności.</p>

<aside>
  <p><strong>Uwaga ES5:</strong> W trybie strict mode, <code>arguments.callee</code> wyrzuci <code>TypeError</code> 
  ponieważ korzystanie z niej jest przestarzałe.</p>
</aside></div></article><article id="function.constructors"><h2>Konstruktory</h2><div><p>Konstruktory w JavaScript również wyglądają inaczej niż innych językach. Każde 
wywołanie funkcji, które jest poprzedone słowem kluczowym <code>new</code>, zachowuje się 
jak konstruktor. </p>

<p>Wewnątrz konstruktora - wywoływanej fukcji - wartość <code>this</code> wskazuje na 
nowo utworzony obiekt <code>Object</code>. Prototyp <a href="#object.prototype"><code>prototype</code></a> tego 
<strong>nowego</strong> obiektu będzie wskazywał na prototyp <code>prototype</code> obiektu fukcji, 
która została wywołana jako konstruktor.</p>

<p>Jeżeli wywołana funkcja nie posiada jawnej deklaracji <code>return</code>, wówczas 
fukcja domyślnie zwraca wartość <code>this</code> - nowy obiekt.</p>

<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();
</code></pre>

<p>Powyżej wywołanya została funkcja <code>Foo</code> jako konstruktor oraz ustawia 
nowo utworzonemu obiektowi właściwość <code>prototype</code> na <code>Foo.prototype</code>.</p>

<p>W tym przypadku jawna deklaracja <code>return</code> w funkcji zwraca wartość 
ustawioną w deklaracji, <strong>ale tylko</strong> jeżeli zwracaną wartością jest 
obiekt <code>Object</code>.</p>

<pre><code>function Bar() {
    return 2;
}
new Bar(); // nowy obiekt

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // zwrócony obiekt
</code></pre>

<p>Jeżeli słowo kluczowe <code>new</code> zostanie pominięte, funkcja <strong>nie</strong> zwróci nowego 
obiektu.</p>

<pre><code>function Foo() {
    this.bla = 1; // zostanie ustawiona w obiekcie global
}
Foo(); // undefined
</code></pre>

<p>Mimo że powyższy kod może zadziałać w pewnych przypadkach, w związku 
z działaniem <a href="#function.this"><code>this</code></a> w języku JavaScript, to jako 
wartość <code>this</code>zostanie wykorzystany <strong>obiekt global</strong>.</p>

</div><div><h3>Fabryki</h3>

<p>Aby móc ominąć słowo kluczowe <code>new</code>, konstruktor musi jawnie zwracać wartość.</p>

<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();
</code></pre>

<p>Oba wywołania <code>Bar</code> zwrócą tę samą rzecz, nowo utworzony obiekt, który posiada 
właściwość nazwaną <code>method</code> i dla którego <code>Bar</code> jest <a href="#function.closures">Domknięciem</a>.</p>

<p>Należy również pamiętać, że wywołanie <code>new Bar()</code> <strong>nie</strong> ma wpływu na 
prototyp zwróconego obiektu (prototypem będzie <code>object.prototype</code> a nie <code>Bar.prototype</code>). 
Kiedy prototyp zostanie przypisany do nowo utworzonego obiektu, <code>Bar</code> nidgy 
nie zwróci tego nowego obiektu <code>Bar</code>, tylko literał obiektu, który jest po 
słowie kluczowym <code>return</code>.</p>

<p>W powyższym przykładzie nie ma żadnej różnicy w działaniu pomiędzy użyciem 
i nieużyciem słowa kluczowego <code>new</code>.</p>

</div><div><h3>Tworzenie nowych obiektów korzystając z fabryk</h3>

<p>Często zaleca się <strong>nie</strong> korzystać z operatora <code>new</code>, ponieważ zapominanie
o jego stosowaniu może prowadzić do błędów.</p>

<p>W celu stworzenia nowego obiektu, powinno się używać fabryki i konstruować 
nowy obiekt wewnątrz tej fabryki.</p>

<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}
</code></pre>

<p>Mimo że powyższy kod jest odporny na brak słowa kluczowego <code>new</code> i ułatwia 
korzystanie ze <a href="#function.closures">zmiennych prywatnych</a>, to posiada 
pewne wady.
While the above is robust against a missing <code>new</code> keyword and certainly makes 
the use of <a href="#function.closures">private variables</a> easier, it comes with some 
downsides.
 1. Zużywa więcej pamięci, ponieważ tworzony obiekt <strong>nie</strong> współdzieli metod 
    poprzez prototyp.
 2. Aby móc dziedziczyć fabryka musi skopiować wszystkie metody z dziedziczonego 
    obiektu lub przypisać ten obiekt, z którego się dziedziczy, jako prototyp 
    do nowo utworzonego obiektu.
 3. Porzucenie łańcucha prototypów tylko ze względu na opuszczone słowo kluczowe
    <code>new</code> jest sprzeczne z duchem języka.</p>

</div><div><h3>Wnioski</h3>

<p>Pominięcie słowa kluczowego <code>new</code> może prowadzić do błędów, ale na pewno nie 
powinno to być powodem odrzucenia używania prototypów w ogóle. Sprowadza się to 
do wyboru rozwiązania, które bardziej pasuje do potrzeb aplikacji. Szczególnie 
ważne jest, aby wybrać określony styl tworzenia obiektów i <strong>trzymać</strong> się go.</p></div></article><article id="function.scopes"><h2>Zasięg zmiennych i przestrzenie nazw</h2><div><p>Mimo że JavaScript radzi sobie dobrze ze składnią opisującą dwa pasujące 
nawiasy klamrowe jako blok, to jednak <strong>nie</strong> wspiera zasięgu blokowego. 
Jedynym zasięgiem jaki istnieje w JavaScript jest <em>zasięg funkcyjny</em>.</p>

<pre><code>function test() { // definiuje zasięg (scope)
    for(var i = 0; i &lt; 10; i++) { // nie definiuje zasięgu (scope)
        // count
    }
    console.log(i); // 10
}
</code></pre>

<aside>
  <p><strong>Uwaga:</strong> Jeżeli notacja <code>{...}</code> nie jest użyta w przypisaniu, deklaracji return
  lub jako argument funkcji, to zostanie zinterpretowana jako deklaracja bloku, 
  a <strong>nie</strong> jako literał obiektu. W połączeniu z <a href="#core.semicolon">automatycznym wstawianiem średnika</a>, 
  może prowadzić do subtelnych błędów.</p>
</aside>

<p>W JavaScripcie nie ma również przestrzeni nazw, co oznacza, że wszystko jest 
definiowane w jednej <em>globalnie współdzielonej</em> przestrzeni nazw. </p>

<p>Z każdym odwołaniem do zmiennej, JavaScript przeszukuje w górę wszystkie zasięgi 
dopóki nie znajdzie tej zmiennej. W przypadku, gdy przeszukiwanie dotrze do globalnego 
zasięgu i nadal nie znajdzie żądanej nazwy, to wyrzuca błąd <code>ReferenceError</code>.</p>

</div><div><h3>Zmora globalnych zmiennych</h3>

<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;
</code></pre>

<p>Powyższe dwa skrypty <strong>nie</strong> dają tego samego efektu. Skrypt A definiuje zmienną 
nazwaną <code>foo</code> w <em>globalnym</em> zasięgu, natomiast skrypt B definiuje <code>foo</code> 
w <em>aktualnym</em> zasięgu.</p>

<p>Jeszcze raz, to wcale nie daje <em>tego samego efektu</em>. Nie użycie <code>var</code> może mieć 
poważne konsekwencje.</p>

<pre><code>// globalny zasięg
var foo = 42;
function test() {
    // lokalny zasięg
    foo = 21;
}
test();
foo; // 21
</code></pre>

<p>Pominięcie słowa <code>var</code> w deklaracji wewnątrz funkcji <code>test</code> nadpisze wartość 
zmiennej globalnej <code>foo</code>. Mimo że nie wygląda to na początku na duży problem, 
posiadanie wielu tysięcy linii kodu w JavaScript i nie korzystanie z <code>var</code> 
wprowadzi straszne i trudne do wyśledzenia błędy.</p>

<pre><code>// globalny zasięg 
var items = [/* jakaś lista */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // scope of subLoop
    for(i = 0; i &lt; 10; i++) { // brakuje słowa var w deklaracji
        // do amazing stuff!
    }
}
</code></pre>

<p>Zewnętrzna pętla zakończy działanie po pierwszym wywołaniu <code>subLoop</code>, ponieważ 
<code>subLoop</code> nadpisuje wartość globalnej zmiennej <code>i</code>. Użycie <code>var</code> w drugiej pętli 
<code>for</code> pozwoliłoby łatwo uniknąć problemu. Słowo kluczowe <code>var</code> nie powinno być 
<strong>nigdy</strong> pominięte w deklaracji, chyba że <em>pożądanym skutkiem</em> jest wpłynięcie na 
zewnętrzny zasięg.</p>

</div><div><h3>Lokalne zmienne</h3>

<p>Jedynym źródłem zmiennych lokalnych w JavaScripcie są parametry <a href="#function.general">funkcji</a> 
oraz zmienne zadeklarowane poprzez deklaracje <code>var</code> wewnątrz funkcji.</p>

<pre><code>// globalny zasięg
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // lokalny zasięg fukcji test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);
</code></pre>

<p>Zmienne <code>foo</code> oraz <code>i</code> są lokalnymi zmiennymi wewnątrz zasiegu funkcji <code>test</code>, 
natomiast przypisanie wartości do <code>bar</code> nadpisze zmienną globalną o tej samej nazwie.</p>

</div><div><h3>"Hoisting" - wywindowanie, podnoszenie</h3>

<p>JavaScript <strong>winduje</strong> deklaracje. Oznacza to, że zarówno deklaracja ze słowem 
kluczowym <code>var</code> jak i deklaracje funkcji <code>function</code> zostaną przeniesione na 
początek otaczającego zasięgu.</p>

<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}
</code></pre>

<p>Powyższy kod zostanie przekształcony przed rozpoczęciem wykonania. JavaScript 
przeniesie deklarację zmiennej <code>var</code> oraz deklarację funkcji <code>function</code> na szczyt 
najbliższego zasięgu.</p>

<pre><code>// deklaracje var zostaną przeniesione tutaj
var bar, someValue; // ustawione domyślnie na &#39;undefined&#39;

// deklaracje funkcji zostaną również przeniesione na górę
function test(data) {
    var goo, i, e; // brak blokowego zasięgu spowoduje przeniesienie tutaj
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // powoduje błąd TypeError ponieważ bar jest nadal &#39;undefined&#39;
someValue = 42; // przypisania nie zostają zmienione przez &#39;hoisting&#39;
bar = function() {};

test();
</code></pre>

<p>Brak blokowego zasięgu nie tylko przeniesie deklaracje <code>var</code> poza ciało pętli,
ale również spowoduje, że niektóre porównania <code>if</code> staną się nieintuicyjne.</p>

<p>W oryginalnym kodzie instrukcja warunkowa <code>if</code> zdaje się modyfikować <em>zmienną 
globalną</em> <code>goo</code>, podczas gdy faktycznie modyfikuje ona <em>zmienną lokalną</em> - po tym 
jak zostało zastosowane windowanie (hoisting).</p>

<p>Bez wiedzy na temat podnoszenia (hoistingu), poniższy kod może sprawiać wrażenie,
że zobaczymy błąd <code>ReferenceError</code>.</p>

<pre><code>// sprawdz czy SomeImportantThing zostało zainicjalizowane
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}
</code></pre>

<p>Oczywiście powyższy kod działa ze względu na fakt, że deklaracja <code>var</code> zostanie 
przeniesiona na początek <em>globalnego zasięgu</em>.</p>

<pre><code>var SomeImportantThing;

// inny kod który może ale nie musi zainicjalizować SomeImportantThing

// upewnienie sie, że SomeImportantThing zostało zainicjalizowane
if (!SomeImportantThing) {
    SomeImportantThing = {};
}
</code></pre>

</div><div><h3>Kolejność rozwiązywania nazw</h3>

<p>Wszystkie zasięgi w JavaScripcie, włączając <em>globalny zasięg</em>, posiadają 
zdefiniowaną wewnątrz specjalną nazwę <a href="#function.this"><code>this</code></a>, która wskazuje 
na <em>aktualny obiekt</em>. </p>

<p>Zasięg funkcyjny posiada również zdefiniowaną wewnętrznie nazwę 
<a href="#function.arguments"><code>arguments</code></a>, która zawiera listę argumentów przekazaną do 
funkcji.</p>

<p>Na przykład, kiedy próbujemy odczytać zmienną <code>foo</code> wewnątrz zasięgu funkcji, 
JavaScript będzie szukać nazwy w określonej kolejności:
 1. Jeżeli wewnątrz aktualnego zasięgu znajduje się deklaracja <code>var foo</code> skorzystaj z niej.
 2. Jeżeli jeden z parametrów fukcji został nazwany <code>foo</code> użyj go.
 3. Jeżeli fukcja została nazwana <code>foo</code> skorzystaj z tego.
 4. Przejdz do zewnętrznego zasięgu i przejdz do kroku <strong>#1</strong>.</p>

<aside>
  <p><strong>Uwaga:</strong> Jeżeli jeden z parametrów fukcji został nazwany <code>arguments</code>, zapobiegnie 
  to utworzeniu domyślnego obiektu <code>arguments</code>.</p>
</aside>

</div><div><h3>Przestrzenie nazw</h3>

<p>Powszechnym problemem posiadania tylko jednej globalnej przestrzeni nazw jest 
prawdopodobieństwo wystąpienia kolizji nazw. W JavaScripcie, można łatwo uniknąć 
tego problemu korzystając z <em>anonimowych wrapperów</em>.</p>

<pre><code>(function() {
    // autonomiczna "przestrzeń nazw"

    window.foo = function() {
        // wyeksponowane domkniecie (closure)
    };

})(); // natychmiastowe wykonanie funkcji
</code></pre>

<p>Anonimowe funkcje są rozpoznane jako <a href="#function.general">wyrażenia</a>, więc 
aby mogły zostać wywołane muszą zostać zewaluowane.</p>

<pre><code>( // zewaluowanie funkcji znajdującej się wewnątrz nawiasów
function() {}
) // zwrócenie obiektu funkcji
() // wywołanie rezultatu ewaluacji
</code></pre>

<p>Istnieją inne sposoby aby zewaluować i wykonać wyrażenie funkcyjne. Mimo że 
mają inną składnię, zachowują się dokładnie tak samo.</p>

<pre><code>// Trzy inne sposoby
!function(){}();
+function(){}();
(function(){}());
</code></pre>

</div><div><h3>Wnioski</h3>

<p>Zaleca się, aby zawsze używać <em>anonimowych wrapperów</em> do hermetyzacji kodu wewnątrz 
jego własnej przestrzeni nazw. To nie tylko chroni kod przed kolizją nazw, ale 
również wprowadza lepszą modularyzację programów.</p>

<p>Ponadto, stosowanie zmiennych globalnych jest uznawane za złą praktykę. 
Wykorzystanie zmiennych globalnych wskazuje na źle napisany kod, który 
jest podatny na błędy i trudny do utrzymania.</p></div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Tablice</h1></header><!-- Articles--><article id="array.general"><h2>Iterowanie po tablicach oraz właściwościach tablic</h2><div><p>Mimo że tablice w JavaScript są obiektami, nie ma dobrych powodów aby używać 
<a href="#object.forinloop"><code>pętli for in</code></a> do iteracji po nich. W rzeczywstości istnieje 
wiele dobrych powodów <strong>przeciwko</strong> wykorzystaniu <code>for in</code> na tablicach.</p>

<aside>
  <p><strong>Uwaga:</strong> Tablice JavaScriptowe <strong>nie</strong> są <em>tablicami asocjacyjnymi</em>. JavaScript
  posiada tylko <a href="#object.general">obiekty</a> do mapowania kluczy do wartości. Jednakże 
  tablice asocjacyjne <strong>zachowują</strong> porządek, natomiast obiekty <strong>nie zachowują</strong>.</p>
</aside>

<p>Ponieważ pętla <code>for in</code> wylicza wszystkie właściwości, które są wewnątrz 
łańcucha prototypów i jedynym sposobem aby wykluczyć te właściwości jest użycie 
<a href="#object.hasownproperty"><code>hasOwnProperty</code></a>, ale wówczas pętla staje się 
<strong>dwadzieście razy</strong> wolniejsza od normalnej pętli <code>for</code>.</p>

</div><div><h3>Iteracja</h3>

<p>W celu osiągnięcia najlepszej wydajności podczas iteracji po tablicach należy 
użyć klasycznej pętli <code>for</code>.</p>

<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}
</code></pre>

<p>W powyższym przykładzie jest jeszcze jeden dodatkowy haczyk. Jest to zbuforowanie 
długości tablicy poprzez <code>l = list.length</code>.</p>

<p>Mimo że właściwość <code>length</code> jest zdefiniowana wewnątrz tablicy, istnieje nadal 
dodatkowy koszt na wyszukiwanie tej właściwości przy każdej iteracji w pętli. 
Chociaż najnowsze silniki JavaScript <strong>mogą</strong> zastosować w tym 
przypadku optymalizację. Nie ma jednak możliwość ustalenia czy kod będzie wykonywany w jednym 
z tych nowych silników, czy też nie.</p>

<p>W rzeczywistości pominięcie buforowania długości tablicy może spowodować, że pętla 
będzie tylko <strong>w połowie tak szybka</strong> jak ta z buforowaniem długości.</p>

</div><div><h3>Właściwość <code>length</code></h3>

<p>Mimo, że <em>getter</em> właściwości <code>length</code> zwraca po prostu liczbę elementów, które są 
zawarte w tablicy, to <em>setter</em> może być użyty do <strong>skracania</strong> tablicy.</p>

<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]
</code></pre>

<p>Przypisanie mniejszej długości spowoduje skrócenie tablicy, ale zwiększenie wartości 
<code>length</code> nie ma żadnego wpływu na tablicę.</p>

</div><div><h3>Wnioski</h3>

<p>Aby uzyskać najlepszą wydajność zaleca się, aby zawsze używać zwykłej pętli <code>for</code>
i zbuforowanie właściwości <code>length</code>. Korzystanie z pętli <code>for in</code> na tablicy jest 
oznaką źle napisanego kodu, który jest podatny na błędy i ma słabą wydajność.</p></div></article><article id="array.constructor"><h2>Konstruktor <code>Array</code></h2><div><p>Zaleca się zawsze korzystać z literału tablicy - notacja <code>[]</code> - podczas tworzenia 
nowych tablic, ponieważ konstruktor <code>Array</code> niejednoznacznie interpretuje 
przekazane do niego parametry.</p>

<pre><code>[1, 2, 3]; // Rezultat: [1, 2, 3]
new Array(1, 2, 3); // Rezultat: [1, 2, 3]

[3]; // Rezultat: [3]
new Array(3); // Rezultat: []
new Array(&#39;3&#39;) // Rezultat: [&#39;3&#39;]
</code></pre>

<p>W przypadku gdy tylko jeden argument zostanie przekazany do kostruktora <code>Array</code> i 
ten argument jest typu <code>Number</code>, konstruktor zwróci nową <em>dziwną</em> tablicę 
z ustawioną właściwością <code>length</code> na wartość przekazaną jako argument. Należy 
zauważyć, że <strong>tylko</strong> właściwość <code>length</code> zostanie ustawiona w ten sposób.
Rzeczywiste indeksy w tej tablicy nie zostaną zainicjalizowane.</p>

<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // zwraca false, indeks nie został ustawiony
</code></pre>

<p>Możliwość ustalenia z góry długości tablicy jest użyteczna tylko w kilku 
przypadkach, jak np. powtarzanie ciągu znaków, w którym unika się stosowania 
pętli <code>for</code>.</p>

<pre><code>// count - ilosc powtorzen
// stringToRepeat - ciąg znaków do powtórzenia 
new Array(count + 1).join(stringToRepeat); 
</code></pre>

</div><div><h3>Wnioski</h3>

<p>W miarę możliwości należy unikać używania konstruktora <code>Array</code>. Literały są 
zdecydowanie lepszym rozwiązaniem. Są krótsze i mają bardziej precyzyjną składnię.
Zwiększają również czytelność kodu.</p></div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Typy</h1></header><!-- Articles--><article id="types.equality"><h2>Równość i porównania</h2><div><p>JavaScript posiada dwa różne sposoby równościowego porównywania obiektów. </p>

</div><div><h3>Operator równości</h3>

<p>Operator równości składa się z dwóch znaków "równa się": <code>==</code></p>

<p>JavaScript jest słabo typowanym językiem. Oznacza to, że operator równości 
<strong>konwertuje</strong> typy (dokonuje <strong>koercji</strong>), aby wykonać porównanie.</p>

<pre><code>""           ==   "0"           // false
0            ==   ""            // true
0            ==   "0"           // true
false        ==   "false"       // false
false        ==   "0"           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
" \t\r\n"    ==   0             // true
</code></pre>

<p>Powyższa tabela przedstawia wyniki koercji typów. Nieprzewidywalne wyniki 
porównania są głównym powodem, że stosowanie <code>==</code> jest powszechnie uważane za złą 
praktykę. Skomplikowane reguły konwersji są powodem trudnych do wyśledzenia błędów.</p>

<p>Ponadto koercja ma również wpływ na wydajność, Na przykład gdy typ String musi zostać 
przekształcony na typ Number przed porównaniem z drugą liczbą.</p>

</div><div><h3>Operator ścisłej równości</h3>

<p>Operator ścisłej równości składa się z <strong>trzech</strong> znaków "równa się": <code>===</code></p>

<p>Działa on dokładnie tak jak normalny operator równości, z jednym wyjątkiem - nie 
dokonuje koercji typów przed porównaniem.</p>

<pre><code>""           ===   "0"           // false
0            ===   ""            // false
0            ===   "0"           // false
false        ===   "false"       // false
false        ===   "0"           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
" \t\r\n"    ===   0             // false
</code></pre>

<p>Powyższe rezultaty są o wiele bardziej przejrzyste. Powoduje to "ustatycznienie"
języka do pewnego stopnia oraz pozwala na wprowadzenie optymalizacji porównań 
obiektów o różnych typach.</p>

</div><div><h3>Porównywanie obiektów</h3>

<p>Mimo że oba operatory <code>==</code> i <code>===</code> nazywane są operatorami <strong>równościowymi</strong>, 
to zachowują się różnie, gdy jednym z operandów jest obiekt typu <code>Object</code>.</p>

<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true
</code></pre>

<p>Oba operatory porównują <strong>toższmość</strong> a <strong>nie</strong> równość, czyli będą porównywać czy 
jeden i drugi operand jest tą samą <strong>instancją</strong> obiektu (podobnie jak operator 
<code>is</code> w Pythonie i porównanie wskaźników w C).  </p>

</div><div><h3>Wnioski</h3>

<p>Zaleca się, aby używać tylko operatora <strong>ścisłej równości</strong>. W sytuacjach gdy 
potrzebna jest koercja (porównanie obiektów różnych typów), konwersja powinna 
być dokonana <a href="#types.casting">jawnie</a>, a nie pozostawiona trudnym regułom koercji 
obowiązującym w języku.</p></div></article><article id="types.typeof"><h2>Operator <code>typeof</code></h2><div><p>Operator <code>typeof</code> (razem z operatorem <a href="#types.instanceof"><code>instanceof</code></a>) jest 
prawdopodobnie najwiekszą wadą konstrukcji języka JavaScript. Posiada on praktycznie <br />
<strong>same wady</strong>.</p>

<p>Mimo że <code>instanceof</code> ma swoje wady to nadal ma ograniczone zastosowanie w praktyce, 
natomiast <code>typeof</code> ma tylko jeden praktyczny przypadek użycia, który na dodatek 
<strong>nie</strong> jest związany z sprawdzaniem typu obiektu.</p>

<aside>
  <p><strong>Uwaga:</strong> Do wywołania operatora <code>typeof</code> może zostać użyta składnia funkcyjna np. 
  <code>typeof(obj)</code>, ale nie jest to wywołanie funkcji. Dwa nawiasy zwrócą obiekt 
  znajdujący się wewnątrz i zwrócona wartość stanie się operandem operatora 
  <code>typeof</code>. <strong>Nie istnieje</strong> funkcja <code>typeof</code>. </p>
</aside>

</div><div><h3>Tablica typów JavaScript</h3>

<pre><code>Wartość             Klasa      Typ
-------------------------------------
"foo"               String     string
new String("foo")   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function("")    Function   function
/abc/g              RegExp     object (function w Nitro i V8)
new RegExp("meow")  RegExp     object (function w Nitro i V8)
{}                  Object     object
new Object()        Object     object
</code></pre>

<p>W powyższej tabeli <em>Typ</em> odnosi się do wartości zwracanej przez operator <code>typeof</code>. 
Wyraźnie widać, że zwracane wartości w ogóle nie są spójne.</p>

<p><em>Klasa</em> odnosi sie do wartości wewnętrznej właściwości <code>[[Class]]</code> obiektu.</p>

<aside>
  <p><strong>Fragment Specyfikacji:</strong> Wartość <code>[[Class]]</code> może być jednym z poniższych 
  stringów. <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, 
  <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>

<p>W celu uzyskania wartości właściwości <code>[[Class]]</code> trzeba skorzystać z metody
<code>toString</code> z <code>Object.prototype</code>. </p>

</div><div><h3>Klasa obiektu</h3>

<p>Specyfikacja zawiera dokładnie jeden sposób dostepu do wartości <code>[[Class]]</code>, 
wykorzystując <code>Object.prototype.toString</code>. </p>

<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true
</code></pre>

<p>Powyższy przykład wywołuje <code>Object.prototype.toString</code> z wartością 
<a href="#function.this">this</a> ustawioną na obiekt, dla której wartość właściwości 
<code>[[Class]]</code> ma zostać odczytana. </p>

<aside>
  <p><strong>Uwaga ES5:</strong> Dla zwiększenia wygody wartość zwracana przez 
  <code>Object.prototype.toString</code> dla <code>null</code> i <code>undefined</code> została zmieniona 
  z <code>Object</code> na <code>Null</code> i <code>Undefined</code> w ECMAScript 5.</p>
</aside>

</div><div><h3>Testowanie niezdefiniowania zmiennej</h3>

<pre><code>typeof foo !== &#39;undefined&#39;
</code></pre>

<p>Powyższy kod sprawdza czy <code>foo</code> została faktycznie zadeklarowana czy też nie. 
Próba odwołania się do zmiennej spowodowała by wyrzucenie błędu <code>ReferenceError</code>. 
Jest to jedyne praktyczne wykorzystanie operatora <code>typeof</code>.</p>

</div><div><h3>Wnioski</h3>

<p>W celu sprawdzenia typu obiektu zalecane jest skorzystanie z 
<code>Object.prototype.toString</code>, ponieważ jest to jedyny wiarygodny sposób. Jak 
pokazano w powyższej tabeli typów, niektóre wartości zwracane przez <code>typeof</code> nie 
są zdefiniowane w specyfikacji, co za tym idzie mogą się różnić w różnych 
implementacjach.</p>

<p>O ile nie operator <code>typeof</code> nie jest użyty do sprawdzania czy zmienna została 
zdefiniowana, powinien być unikany <strong>jeśli to tylko możliwe</strong>.</p></div></article><article id="types.instanceof"><h2>Operator <code>instanceof</code></h2><div><p>Operator <code>instanceof</code> porównuje konstruktory obiektów przekazanych jako operendy. 
Jest on użyteczny jedynie do porównywania obiektów utworzonych klas. Stosowanie 
go na wbudowanych typach jest praktycznie tak samo bezużyteczne, jak operatora
<a href="#types.typeof">typeof</a>.</p>

</div><div><h3>Porównywanie obiektów utworzonych klas</h3>

<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// poniżej kod który przypisuje do Bar.prototype obiekt funkcji Foo
// a nie faktyczną instancję Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false
</code></pre>

</div><div><h3>Stosowanie <code>instanceof</code> na natywnych typach</h3>

<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false
</code></pre>

<p>Jedną ważną rzeczą, którą należy zauważyć jest to, że <code>instanceof</code> nie zadziała 
na obiektach, które pochodzą z różnych kontekstów JavaScript (np. z różnych 
dokumentów wewnątrz przeglądarki), ponieważ ich konstruktory nie będą tymi 
samymi obiektami.</p>

</div><div><h3>Wnioski</h3>

<p>Operator <code>instanceof</code> powinien być używany <strong>wyłącznie</strong> podczas korzystania z obiektów 
klas utworzonych, które były zdefiniowane w tym samym kontekscie JavaScriptowym. 
Podobnie jak operator <a href="#types.typeof"><code>typeof</code></a>, należy <strong>unikać</strong> korzystania 
z tego operatora w innych sytuacjach.</p></div></article><article id="types.casting"><h2>Rzutowanie typów</h2><div><p>JavaScript jest językiem słabo typowanym. Co za tym idzie, będzie stosować koercję 
typów <strong>gdziekolwiek</strong> jest to możliwe.</p>

<pre><code>// te zwracają true
new Number(10) == 10; // Number.toString() zostanie przekształcone
                      // z powrotem do liczby

10 == &#39;10&#39;;           // stringi zostaną przekształcone do typu Number
10 == &#39;+10 &#39;;         // kolejne wariacje
10 == &#39;010&#39;;          // i następne
isNaN(null) == false; // null zostanie przekształcony do 0
                      // który oczywiście nie jest NaN

// poniższe zwracają false
10 == 010;
10 == &#39;-10&#39;;
</code></pre>

<aside>
  <p>**Uwaga ES5: Literały liczbowe zaczynające sie od <code>0</code> są interpretowane jako
  liczby w systemie ósemkowym. W trybie strict mode w ECMAScript 5 wsparcie dla 
  liczb ósemkowych zostało porzucone.</p>
</aside>

<p>Aby uniknąć powyższych problemów, należy <strong>koniecznie</strong> korzystać ze 
<a href="#types.equality">ściełego operatora równości</a>. Mimo, że pozwala to uniknąć wiele 
typowych problemów to nadal istnieje wiele innych, które powstają na bazie słabego 
typowania języka JavaScript.</p>

</div><div><h3>Konstruktory typów wbudowanych</h3>

<p>Konstruktory typów wbudowanych, takich jak <code>Number</code> lub <code>String</code>, zachowują się 
inaczej kiedy są poprzedzone słowem kluczowym <code>new</code> a inaczej kiedy nie są.</p>

<pre><code>new Number(10) === 10;     // False, Object i Number
Number(10) === 10;         // True, Number i Number
new Number(10) + 0 === 10; // True, ponieważ dokonano jawnej konwersji
</code></pre>

<p>Korzystanie z wbudowanych typów jak <code>Number</code> jako konstruktora tworzy nowy obiekt 
typu <code>Number</code>, natomiast opuszczenie słowa kluczowego <code>new</code> powoduje, że funkcja 
<code>Number</code> zachowuje się jak konwerter.</p>

<p>Ponadto, użycie literałów lub wartości nieobiektowych zaowocuje jeszcze większą 
ilością rzutowań (koercją) typów.</p>

<p>Najlepszym rozwiązaniem jest <strong>jawne</strong> rzutowanie do jednego z trzech typów.</p>

</div><div><h3>Rzutowanie do typu String</h3>

<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true
</code></pre>

<p>Konkatenacja pustego stringu i wartości powoduje rzutowanie do typu String. </p>

</div><div><h3>Rzutowanie do typu Number</h3>

<pre><code>+&#39;10&#39; === 10; // true
</code></pre>

<p>Zastosowanie <strong>unarnego</strong> operatora + spowoduje rzutowanie do typu Number.</p>

</div><div><h3>Rzutowanie do typu Boolean</h3>

<p>Używając dwukrotnie operatora <strong>negacji</strong>, dowolna wartość może zostać zrzutowana 
do typu Boolean</p>

<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true
</code></pre></div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Jądro</h1></header><!-- Articles--><article id="core.eval"><h2>Dlaczego nie należy używać <code>eval</code>?</h2><div><p>Funkcja <code>eval</code> uruchomi podany string jako kod JavaScript w lokalnym zasięgu (scopie).</p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1
</code></pre>

<p>Niestaty, <code>eval</code> zostanie wykonana w lokalnym zasięgu tylko wtedy, gdy zostanie wywołana 
<strong>bezpośrednio</strong> <em>i</em> nazwa wywoływanej funkcji równa sie <code>eval</code>.  </p>

<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3
</code></pre>

<p>Należy unikać stosowania <code>eval</code> <strong>o ile to tylko możliwe</strong>. W 99.9% przypadków można 
osiągnąć ten sam efekt <strong>nie</strong> używając <code>eval</code>.</p>

</div><div><h3><code>eval</code> w przebraniu</h3>

<p><a href="#other.timeouts">Funkcje wykonywane po upływie czasu</a> <code>setTimeout</code> i <code>setInterval</code> 
mogą przyjąć string jako pierwszy argument. String ten <strong>zawsze</strong> będzie wykonywany 
w globalnym zasięgu, ponieważ funkcja <code>eval</code> jest w tym wypadku wywoływana pośrednio.</p>

</div><div><h3>Problemy z bezpieczeństwem</h3>

<p>Funkcja <code>eval</code> jest również problematyczna od strony bezpieczeństwa, ponieważ 
wykonuje <strong>każdy</strong> kod, który zostanie do niej przekazany i <strong>nigdy</strong> nie należy
jej używać na stringach nieznanego lub niezaufanego pochodzenia.</p>

</div><div><h3>Wnioski</h3>

<p>Funkcja <code>eval</code> nie powinna być w ogóle używana. Każdy kod, który jej używa
powinien zostać sprawdzony pod względem działania, wydajności i bezpieczeństwa. 
W przypadku gdy użycie <code>eval</code> jest niezbędne do działania, wówczas taki kod 
należy ponownie przemyśleć i <em>ulepszyć</em> aby nie wymagał użycia <code>eval</code>. </p></div></article><article id="core.undefined"><h2><code>undefined</code> i <code>null</code></h2><div><p>JavaScript ma dwie różne wartości dla <code>pustych</code> wartości, bardziej użyteczną 
z tych dwóch jest <code>undefined</code>.</p>

</div><div><h3>Wartość <code>undefined</code></h3>

<p><code>undefined</code> jest typem z dokładnie jedną wartością: <code>undefined</code>.</p>

<p>Język również definiuje globalną zmienną, która ma wartość <code>undefined</code> - zmienna 
ta jest nazwana <code>undefined</code>. Jednakże jest to zmienna a <strong>nie</strong> stała, czy słowo 
kluczowe. Oznacza to, że możliwe jest nadpisanie <em>wartości</em> tej zmiennej.</p>

<aside>
  <p>Uwaga ES55: <code>undefined</code> w ECMAScript 5 <strong>nie będzie już</strong> <em>nadpisywalna</em> w trybie
  strict mode, ale jej nazwa może zostać przesłoniona przez na przykład funkcję o 
  nazwie <code>undefined</code>.</p>
</aside>

<p>Kilka przykładów kiedy wartość <code>undefined</code> jest zwracana:</p>

<ul>
<li>dostęp do (niemodyfikowalnej) zmiennej globalnej <code>undefined</code>,</li>
<li>wyjście z funkcji, która nie ma deklaracji <code>return</code>,</li>
<li>deklaracja <code>return</code>, która nic jawnie nie zwraca,</li>
<li>poszukiwanie nieistniejącej właściwości,</li>
<li>parametr funkcji, który nie został jawnie przekazany podczas wywołania funkcji,</li>
<li>wszystko czemu została przypisana wartość <code>undefined</code>.</li>
</ul>

</div><div><h3>Obsługa przypadku zmiany wartości <code>undefined</code></h3>

<p>Ponieważ globalna zmienna <code>undefined</code> zawiera tylko kopię prawdziwej <em>wartości</em> typu 
<code>undefined</code>, przypisanie nowej wartości do tej zmiennej <strong>nie</strong> zmienia wartości 
<em>typu</em> <code>undefined</code>.</p>

<p>Jednak aby porównać coś z wartością <code>undefined</code>, trzeba odczytać wartość <code>undefined</code>.</p>

<p>Aby uchronić swój kod przed możliwym nadpisaniem zmiennej <code>undefined</code>, korzysta 
się z powszechnej techniki dodania dodatkowego parametru do 
<a href="#function.scopes">anonimowego wrappera</a>, do którego nie zostanie przekazany 
argument.</p>

<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // undefined o lokalnym zasięgu znowu 
    // odnosi się do poprawnej wartości

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>Kolejnym sposobem na osiągnięcie tego samego efektu jest użycie deklaracji zmiennej 
wewnątrz wrappera.</p>

<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);
</code></pre>

<p>Jedyną różnicą pomiędzy tymi sposobami są dodatkowe 4 bajty przeznaczone na słowo 
kluczowe <code>var</code> i spację po nim.</p>

</div><div><h3>Zastosowanie <code>null</code></h3>

<p>Podczas gdy <code>undefined</code> w kontekście języka jest używany jak <em>null</em> w sensie 
tradycyjnych języków, <code>null</code> w JavaScript (jako literał i jako typ) jest po 
prostu kolejnym typem danych.</p>

<p>Jest wykorzystywany we wnętrzu JavaScript (np. deklaracji końca łańcucha prototypów 
poprzez ustawienie <code>Foo.prototype = null</code>), ale prawie w każdym przypadku można go 
zastąpić przez <code>undefined</code>.</p></div></article><article id="core.semicolon"><h2>Automatyczne wstawianie średnika</h2><div><p>Mimo że JavaScript ma składnię podobną do języka C, to <strong>nie</strong> wymusza stosowania 
średników w kodzie źródłowym. Istnieje możliwość ich pominięcia.  </p>

<p>JavaScript nie jest językiem bez średników, tak na prawdę potrzebuje 
średników aby zinterpretować kod źródłowy. Jednakże parser JavaScript 
<strong>automatycznie</strong> wstawia średniki o ile napotka błąd parsowania związany z 
brakiem średnika.</p>

<pre><code>var foo = function() {
} // błąd parsowania, oczekiwany był w tym miejscu średnik
test()
</code></pre>

<p>Parser dodaje średnik, i próbuje jeszcze raz sparsować skrypt.</p>

<pre><code>var foo = function() {
}; // bez błędu parser kontynuuje
test()
</code></pre>

<p>Automatyczne wstawianie średników jest uważane za jeden z <strong>największych</strong> błędów 
konstrukcji języka, ponieważ <em>może</em> ono zmienić zachowanie kodu.</p>

</div><div><h3>Jak działa wstawianie</h3>

<p>Kod poniżej nie ma żadnych średników, więc parser zdecyduje, w których miejscach 
je wstawi.</p>

<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)
</code></pre>

<p>Poniżej znajduje się rezultat "zgadywania" parsera.</p>

<pre><code>(function(window, undefined) {
    function test(options) {

        // Nie wstaniony średnik, linie zostały połączone
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- wstawiony

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- wstawiony

        return; // &lt;- wstawiony, psując deklarację return
        { // potraktowane jako definicja bloku

            // etykieta oraz pojedyncze wyrażenie
            foo: function() {} 
        }; // &lt;- wstawiony
    }
    window.test = test; // &lt;- wstawiony

// Kolejna połączona linia
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- wstawiony

})(window); //&lt;- wstawiony
</code></pre>

<aside>
  <p><strong>Uwaga:</strong> Parser JavaScript nie potrafił "odpowiednio" zinterpretować 
  deklaracji return, po której został dodany znak nowej linii. Mimo że 
  niekoniecznie jest to błąd automatycznego wstawiania średników, to może to 
  jednak powodować niechciane efekty uboczne </p>
</aside>

<p>Parser drastycznie zmienił działanie powyższego kodu. W niektórych przypadkach 
<strong>zmienił go źle</strong>.</p>

</div><div><h3>Nawiasy</h3>

<p>W przypadku, gdy w następnej linii znajduje się nawias, parser <strong>nie</strong> wstawi 
średnika.</p>

<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})
</code></pre>

<p>Kod ten zostanie zmieniony w poniższą linię.</p>

<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})
</code></pre>

<p>Jest <strong>bardzo</strong> prawdopodobne, że <code>log</code> <strong>nie</strong> zwróci fukcji. Co za tym idzie 
powyższy kod wyrzuci błąd <code>TypeError</code> oznajmując, że <code>undefined is not a 
function</code> - <code>undefined</code> nie jest funkcją.</p>

</div><div><h3>Wnioski</h3>

<p>Zaleca się, aby <strong>nigdy</strong> nie pomijać średników, pozostawiać nawias otwierający 
w tej samej linii co odpowiadająca mu definicja i nigdy nie pozostawiać deklaracji 
<code>if</code> / <code>else</code> bez nawiasów - nawet, jeżeli są jednolinijkowe. Wszystkie te uwagi nie 
tylko pomagają poprawić spójność kodu, ale też zapobiegają zmianie działania 
kodu przez parser JavaScript.</p></div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Inne</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> i <code>setInterval</code></h2><div><p>Ponieważ JavaScript jest asynchroniczny, istnieje możliwość zaplanowania wykonania 
funkcji przy użyciu funkcji <code>setTimeout</code> i <code>setInterval</code>.
Since JavaScript is asynchronous, it is possible to schedule the execution of a 
function by using the <code>setTimeout</code> and <code>setInterval</code> functions.</p>

<aside>
  <p><strong>Note:</strong> Funkcje czasowe nie są częścią standardu ECMAScript. Jest to część 
  standardu <a href="http://pl.wikipedia.org/wiki/Obiektowy_model_dokumentu" title="Document Object Model">DOM</a>.</p>
</aside>

<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // zwraca liczbę typu Number &gt; 0
</code></pre>

<p>Powyższe wywołanie <code>setTimeout</code> zwraca ID budzika i planuje wywołanie <code>foo</code> za 
<strong>około</strong> tysiąc milisekund. <code>foo</code> zostanie wykonana dokładnie <strong>jeden raz</strong>.</p>

<p><strong>Nie ma pewności</strong>, że kod zaplanowany do wykonania wykona się dokładnie po 
upłynięciu zadanego czasu podanego jako parametr do <code>setTimeout</code>, ponieważ zależy 
to od dokładności zegara w silniku JavaScript, który wykonuje kod oraz od tego, 
że inny kawałek kodu może zablokować wątek, ponieważ JavaScript jest tylko 
jednowątkowy.</p>

<p>Funkcja, która została przekazana jako pierwszy parametr zostanie wykonana w 
globalnym zasięgu, co oznacza, że <a href="#function.this"><code>this</code></a> wewnątrz tej funkcji 
będzie wskazywać na obiekt <em>global</em>.</p>

<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this wskazuje na obiekt global
        console.log(this.value); // wypisze undefined
    };
    setTimeout(this.method, 500);
}
new Foo();
</code></pre>

<aside>
  <p><strong>Uwaga:</strong> Ponieważ <code>setTimeout</code> przyjmuje <strong>obiekt funkcji</strong> jako pierwszy 
  argument, często popełnianym błędem jest wykorzystanie składni <code>setTimeout(foo(), 1000)</code>, 
  która użyje wartości zwróconej przez funkcję <code>foo</code> jako parametru zamiast 
  funkcji <code>foo</code> samej w sobie. W większości przypadków będzie to cichy błąd, 
  ponieważ jeżeli funkcja zwróci <code>undefined</code>, <code>setTimeout</code> <strong>nie</strong> wyrzuci żadnego 
  błędu.</p>
</aside>

</div><div><h3>Kolejkowanie wywołań z <code>setInterval</code></h3>

<p>Podczas gdy <code>setTimeout</code> wywołuje podaną funkcję tylko raz, <code>setInterval</code> - 
jak wskazuje nazwa - będzie wykonywać funkcję <strong>w odstępach czasowych</strong> co <code>X</code> 
milisekund. Jednakże korzystanie z tej funkcji jest odradzane.</p>

<p>Kiedy wykonywany kod zablokuje możliwość uruchomienia zaplanowanej funkcji, 
<code>setInterval</code> będzie próbować uruchamiać daną funkcję, co będzie powodować 
kolejkowanie wykonania tej samej funkcji kilkukrotnie. Może się to zdażyć
szczególnie przy krótkim interwale.</p>

<pre><code>function foo(){
    // coś co blokuje wykonanie na 1 sekundę 
}
setInterval(foo, 100);
</code></pre>

<p>W powyższym kodzie kod <code>foo</code> zostanie wywołany tylko raz i zablokuje wywołanie na 
jedną sekundę.</p>

<p>Podczas, gdy funkcja <code>foo</code> blokuje wykonanie, <code>setInterval</code> będzie planować kolejne 
wywołania <code>foo</code>. W momencie, gdy pierwsze wywołanie <code>foo</code> się zakończy, 
w kolejce do wywołania będzie już czekało kolejne <strong>dziesięć</strong> wywołań tej funkcji.</p>

</div><div><h3>Radzenie sobie z możliwymi blokadami</h3>

<p>Najprostszą, jak również najbardziej kontrolowaną sytuacją, jest użycie <code>setTimeout</code> 
wewnątrz wywoływanej funkcji.</p>

<pre><code>function foo(){
    // coś co blokuje wykonanie na 1 sekundę
    setTimeout(foo, 100);
}
foo();
</code></pre>

<p>Powyższy kod nie tylko hermetyzuje wywołanie <code>setTimeout</code>, ale też zapobiega 
kolejkowaniu wywołań funkcji i daje dodatkową kontrolę. W tym przypadku funkcja 
<code>foo</code> może zdecydować czy powinna się wywołać ponownie, czy też nie.</p>

</div><div><h3>Ręczne usuwanie budzików</h3>

<p>Usuwanie budzików i interwałów dokonywane jest przez przekazanie odpowiedniego ID 
do <code>clearTimeout</code> lub <code>clearInterval</code>, w zależności z jakiej funkcji zostało 
zwrócone ID.</p>

<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);
</code></pre>

</div><div><h3>Usuwanie wszystkich budzików</h3>

<p>Ponieważ nie istnieje wbudowana metoda usuwania wszystkich budzików i/lub 
interwałów, do osiągnięcia tego efektu konieczne jest użycie metody &#39;brute force&#39;.</p>

<pre><code>// usunięcie "wszystkich" budzików 
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}
</code></pre>

<p>Nadal mogą istnieć jakieś budziki, na które powyższy kawałek kodu nie zadziała. 
Ponieważ ID było z innego przedziału, zamiast korzystania z metody brute force, 
zaleca się śledzić wszystkie numery ID budzików, aby można je było usunąć.</p>

</div><div><h3>Ukryte wykorzystanie <code>eval</code></h3>

<p>Do <code>setTimeout</code> i <code>setInterval</code> można również przekazać string jako pierwszy 
parametr zamiast obiektu funkcji, jednakże <strong>nigdy</strong> nie należy korzystać z tej 
możliwości, ponieważ wewnętrznie <code>setTimeout</code> i <code>setInterval</code> wykorzystują <code>eval</code>.</p>

<aside>
  <p><strong>Uwaga:</strong> Ponieważ funkcje budzików <strong>nie</strong> są częścią specyfikacji standardu
  ECMAScript, działanie tych funkcji nie jest określone w momencie, gdy zostanie 
  do nich przekazany string. Na przykład Microsoftowy JScript wykorzystuje 
  konstruktor <code>Function</code> zamiast funkcji <code>eval</code>.</p>
</aside>

<pre><code>function foo() {
    // zostanie wykonane 
}

function bar() {
    function foo() {
        // nigdy nie zostanie wywołane
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();
</code></pre>

<p>Ponieważ <code>eval</code> nie zostało wywołane w tym przypadku <a href="#core.eval">wprost</a>, to 
string przekazany do <code>setTimeout</code> zostanie uruchomiony w <em>zasięgu globalnym</em>. 
Co za tym idzie, lokalna zmienna <code>foo</code> z zasięgu <code>bar</code> nie zostanie użyta.</p>

<p>Kolejnym zaleceniem jest <strong>niestosowanie</strong> stringów do przekazywania argumentów 
do funkcji, która ma zostać wywołana przez budzik.</p>

<pre><code>function foo(a, b, c) {}

// NIGDY nie należy tak robić 
setTimeout(&#39;foo(1,2, 3)&#39;, 1000)

// zamiast tego należy skorzystać z anonimowej funkcji
setTimeout(function() {
    foo(a, b, c);
}, 1000)
</code></pre>

<aside>
  <p><strong>Uwaga:</strong> Mimo że możliwe jest wykorzystanie składni
  <code>setTimeout(foo, 1000, a, b, c)</code>, nie zaleca się korzystania z niej, ponieważ 
  może to prowadzić do subtelnych błędów podczas wykorzystania <a href="#function.this">metod</a>.</p>
</aside>

</div><div><h3>Wnioski</h3>

<p><strong>Nigdy</strong> nie należy przekazywać stringu jako parametru do <code>setTimeout</code> lub 
<code>setInterval</code>. Jest to wyraźną oznaką <strong>bardzo</strong> złego kodu. Jeżeli potrzebne jest 
przekazanie argumentów do funkcji, należy skorzystać z <em>anonimowej funkcji</em> i 
wewnątrz niej dokonać przekazania argumentów.</p>

<p>Ponadto, należy unikać korzystania z <code>setInterval</code>, ponieważ planista może 
zablokować wykonanie JavaScriptu.</p></div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with 
<a href="http://nodejs.org/">Node.js </a>using a
<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by 
<a href="http://cramerdev.com">Cramer Development</a>.
</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/plugin.js"></script><script src="../javascript/garden.js"></script></body></html>