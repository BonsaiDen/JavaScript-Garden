## Как работает `this`

В JavaScript зона ответственности специальной переменной `this` концептуально отличается от тех, за которые отвечает `this` в других языках программирования. Различают ровно **пять** сущностей, к которым в этом языке может быть привязана переменная `this`.

### 1. Глобальная область видимости

    this;

Когда мы используем `this` в глобальной области видимости, она просто ссылается на *глобальный* объект.

### 2. Вызов функции

    foo();

Внутри функции `this` ссылается на *глобальный* объект.

> **Замечание касательно ES5:** В strict-режиме **отсутствует** понятие глобальной видимости, поэтому `this` в этом случае будет иметь значение `undefined`.

### 3. Вызов метода

    test.foo();

Внутри метода `this` ссылается на `test`.

### 4. Вызов конструктора

    new foo();

Если перед вызовом функции присутствует ключевое слово `new` то данная функция будет действовать как [конструктор](#function.constructors). Внутри такой функции `this` будет указывать на *новый созданный* `Object`.

### 5. Переопределение `this`

    function foo(a, b, c) {}

    var bar = {};
    foo.apply(bar, [1, 2, 3]); // внутри foo массив развернётся в аргументы
    foo.call(bar, 1, 2, 3); // аналогично: a = 1, b = 2, c = 3

Когда мы используем методы `call` или `apply` из `Function.prototype`, то внутри вызваемой функции `this` **явным образом** будет присвоено значение первого передаваемого параметра.

Исходя из этого, в предыдущем примере (строка с `apply`), правило №3 *«вызов метода»* **не** будет применёно, и `this` внутри `foo` будет присвоено `bar`.

> **Замечание:** `this` **нельзя** использовать внутри литералов `{}` (`Object`) для ссылки на сам объект. Т.е. если мы напишем `var obj = {me: this}`, то `me` не будет ссылаться на `obj`, поскольку `this` присваивается только по одному из пяти описанных правил.

### Наиболее распространенные ловушки

Хотя большинство из примеров ниже имеют смысл, первый из них можно причислить к упущениям в самом языке, поскольку он **вообще** не имеет практических применений.

    Foo.method = function() {
        function test() {
            // this ссылается на глобальный объект
        }
        test();
    }

Распространено заблуждение о том, что `this` внутри `test` ссылается на `Foo`, но это совсем **не так**.

Для того, чтобы получить доступ к `Foo` внутри функции `test`, необходимо создать локальную переменную внутри `method`, которая и будет ссылаться на `Foo`.

    Foo.method = function() {
        var that = this;
        function test() {
            // Здесь используем that вместо this
        }
        test();
    }

Подходящее имя для такой переменной — `that`, и его часто используют для ссылки на внешний `this`. В комбинациях с [замыканиями](#function.closures) такая переменная может использоваться, чтобы «пробрасывать» `this` в глобальную область, или в любой другой объект.

### Присвоение методов

Еще одной возможностью, которая могла бы работать, но **не** работает в `JavaScript`, является создание псевдонимов (алиасов) для методов, т.е. **присвоение** метода объекта переменной.

    var test = someObject.methodTest;
    test();

Следуя первому правилу, `test` вызывается как обычная функция; следовательно `this` внутри него больше не ссылается на `someObject`.

Хотя позднее связывание `this` на первый взгляд может показаться не очень хорошей идеей, но на самом деле это именно то, благодаря чему работает [наследование прототипов](#object.prototype).

    function Foo() {}
    Foo.prototype.method = function() {};

    function Bar() {}
    Bar.prototype = Foo.prototype;

    new Bar().method();

В момент, когда будет вызван `method` нового экземляра `Bar`, `this` будет ссылаться на этот самый экземпляр.

