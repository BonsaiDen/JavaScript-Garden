## Области видимости и пространства имён

Хотя JavaScript вполне нормально воспринимает синтаксис двух сопоставимых фигурных скобок, окружающих блок, он **не** поддерживает блочную область видимости; всё что остаётся на этот случай в языке — *область видимости функций*.

    function test() { // область видимости
        for(var i = 0; i < 10; i++) { // не область видимости
            // считаем
        }
        console.log(i); // 10
    }

> **Замечание:** Нотация `{...}` будет интерпретирована как блочное выражение, а **не** как литерал объекта, если она не используется в присваивании, операторе `return` или в качестве функции. Это замечание, вкупе с [автоматической расстановкой точек с запятой](#core.semicolon), может привести к чрезвычайно изощрённым ошибкам.

Также JavaScript не различает пространств имён: всё определяется на том или ином уровне в единственном *глобально доступном* пространстве имён.

Каждый раз, когда JavaScript обнаруживает ссылку на переменную, он будет искать её всё выше и выше по областям видимости, пока не найдёт её. В случае, если он достигнет глобальной области видимости и не найдет запрошенное имя и там тоже, он выбросит `ReferenceError`.

### Проклятие глобальных переменных

    // скрипт A
    foo = '42';

    // скрипт B
    var foo = '42'

Вышеприведённые два скрипта отнюдь **не** приводят к одинаковому результату. Скрипт A определяет переменную по имени `foo` в *глобальной* области видимости, а скрипт B определяет `foo` в текущей области видимости.

Повторимся, это **совсем не** *тот же самый эффект*. Если вы не используете `var` — то вы в большой опасности.

    // глобальная область видимости
    var foo = 42;
    function test() {
        // локальная область видимости
        foo = 21;
    }
    test();
    foo; // 21

Из-за того что оператор `var` был опущен внутри функции, фунция `test` перезапишет значение `foo`. Это поначалу может показаться не такой уж и большой проблемой, но если у вас имеется тысяча строк JavaScript-кода и вы не используете `var`, то вам на пути встретятся самые страшные и трудноотлаживаемые ошибки — и это не шутка.

    // глобальная область видимости
    var items = [/* какой-то список */];
    for(var i = 0; i < 10; i++) {
        subLoop();
    }

    function subLoop() {
        // область видимости subLoop
        for(i = 0; i < 10; i++) { // пропущен оператор var
            // происходят волшебные вещи!
        }
    }

Внешний цикл прекратит работу сразу после первого вызова `subLoop`, поскольку `subLoop` перезаписывает глобальное значение переменной `i`. Использование `var` во втором цикле `for` могло бы вас легко избавить от этой ошибки. **Никогда** не забывайте использовать `var`, если только вы не обладаете полностью *осознанным намерением* повлиять на внешнюю область видимости.

### Локальные переменные

Единственный источник локальных переменных в JavaScript - это параметры [функций](#function.general) и переменные, объявленные с использованием оператора `var`.

    // глобальная область видимости
    var foo = 1;
    var bar = 2;
    var i = 2;

    function test(i) {
        // локальная область видимости для функции test
        i = 5;

        var foo = 3;
        bar = 4;
    }
    test(10);

В то время как `foo` и `i` — локальные переменные в области видимости функции `test`, присвоение `bar` переопределит значение одноимённой глобальной переменной.

### Вытягивание

JavaScript **«вытягивает»** определения. Это значит, что оба определения с использованием `var` и определение `function` будут перенесены наверх из заключающей их области видимости.

    bar();
    var bar = function() {};
    var someValue = 42;

    test();
    function test(data) {
        if (false) {
            goo = 1;

        } else {
            var goo = 2;
        }
        for(var i = 0; i < 100; i++) {
            var e = data[i];
        }
    }

Этот код трансформируется ещё перед исполнением. JavaScript перемещает операторы `var` и определение `function` наверх ближайшей оборачивающей области видимости.

    // выражения с var переместились сюда
    var bar, someValue; // по умолчанию - 'undefined'

    // определение функции тоже переместилось
    function test(data) {
        var goo, i, e; // упущенная область видимости
                       // переместила их сюда
        if (false) {
            goo = 1;

        } else {
            goo = 2;
        }
        for(i = 0; i < 100; i++) {
            e = data[i];
        }
    }

    bar(); // вылетает с ошибкой TypeError,
           // поскольку bar всё ещё 'undefined'
    someValue = 42; // присвоения не зависят от вытягивания
    bar = function() {};

    test();

Потерянная область видимости не только переместит операторы `var` вовне циклов и их тел, но и лишит смысла конструкцию c `if.

Предполагалось, что в исходном коде оператор `if` изменял *глобальную переменную* `goo`, однако, как оказалось, он изменял *локальную переменную* — в результате работы вытягивания.

Если вы не знакомы с *вытягиваниями*, то можете предположить, что нижеприведённый код должен выбросить
`ReferenceError`.

    // проверить, проинициализована ли SomeImportantThing
    if (!SomeImportantThing) {
        var SomeImportantThing = {};
    }

Но, конечно же, этот код работает: из-за того, что оператор `var` был перемещён наверх *глобальной области видимости*

    var SomeImportantThing;

    // другой код может инициализировать здесь переменную SomeImportantThing,
    // а может и нет

    // убедиться, что она всё ещё здесь
    if (!SomeImportantThing) {
        SomeImportantThing = {};
    }

### Порядок разрешения имён

Все области видимости в JavaScript, включая *глобальную область видимости*, содержат специальную, определённую внутри них, переменную [`this`](#function.this), которая ссылается на *текущий объект*.

Области видимости функций также содержат внутри себя переменную [`arguments`](#function.arguments), которая содержит аргументы, переданные в функцию.

Например, когда JavaScript пытается получить доступ к переменной `foo` в области видимости функции, он будет искать её по имени в такой последовательности:

 1. Если в текущей области видимости есть выражение `var foo`, использовать эту переменную.
 2. Если один из параметров функции называется `foo`, использовать этот параметр.
 3. Если функциия сама называется `foo`, использовать её.
 4. Перейти на одну область видимости выше и повторить, начиная с **п. 1**

> **Замечание:** Наличие параметра функции с именем `arguments` **не позволит** движку создать объект `arguments`, создающийся, в других случаях, по умолчанию.

### Пространства имён

Нередко можно столкнуться с неприятным последствием от наличия одного единственного глобального пространства имён — проблемы с перекрытием имён переменных. В JavaScript эту проблему легко избежать, используя *анонимные обёртки*.

    (function() {
        // самодостаточное «пространство имён»

        window.foo = function() {
            // открытое замыкание
        };

    })(); // сразу же выполнить функцию

Безымянные функции являются отложенными [выражениями](#function.general) (_прим. перев._ — то есть, они не разбираются по месту описания, а откладываются парсером напоследок); поэтому, чтобы вы сделать их исполняемыми, следует спровоцировать их разбор.

    ( // разобрать функцию внутри скобок
    function() {}
    ) // и вернуть объект функции
    () // вызвать результат разбора

Есть другие способы спровоцировать разбор и последующий вызов выражения с функцией; они, хоть и различаются в синтаксисе, действуют одинаково:

    // Два других способа
    +function(){}();
    (function(){}());

<!--

> **На заметку:** ''прим. перев.'' в JavaScript кроме прочего существует конструкция `new function() {}`, она очень редко используется, но позволяет создать **новый экземпляр** анонимной функции. Например, если вы присваивате нескольким объектам одну и ту же анонимную функцию-конструктор, то `instanceof` перестаёт работать, здесь вам и поможет `new function()`.

-->

### Заключение

Рекомендуется всегда использовать *анонимную обёртку* чтобы заключить код в собственное пространство имён. Это не только защищает код от совпадений имён, но и позволяет создавать модульные программы.

Важно добавить, что использование глобальных переменных считается **плохой практикой**. **Любое** их использование демонстрирует плохое качество кода, предполагает его высокую подверженность ошибкам и сложность в его разборе.

