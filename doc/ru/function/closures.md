## Замыкания и ссылки

Одним из самых мощных инструментов язка JavaScript считают возможность создавать *замыкания*. Это такой приём, когда новые области видимости (например, функций) **всегда** имеют доступ к внешней области, в которых они были объявлены. Собственно, единственный механизм создания областей видимости в JavaScript — это и есть [функции](#function.scopes): таким образом, объявляя функцию, вы автоматически реализуете замыкания. Или, другими словами: любая объявленная функция по умолчанию ведёт себя как замыкание.

### Эмуляция приватных переменных

    function Counter(start) {
        var count = start;
        return {
            increment: function() {
                count++;
            },

            get: function() {
                return count;
            }
        }
    }

    var foo = Counter(4);
    foo.increment();
    foo.get(); // 5

В данном примере `Counter` возвращает **два** замыкания: функции `increment` и `get`. Обе эти функции сохраняют внутри себя **ссылку** на область видимости `Counter` и, соответственно, имеют свободный доступ к переменной `count` из этой самой области.

### Как работают приватные переменные

Поскольку в JavaScript нельзя присваивать или ссылаться на области видимости, заполучить `count` извне — **не** представляется возможным. Единственный способ взаимодействовать с этой переменной — изменять её внутри двух описанных замыканий.

    var foo = new Counter(4);
    foo.hack = function() {
        count = 1337;
    };

В приведенном примере мы **не** изменяем переменную `count` из области видимости `Counter`, т.к. `foo.hack` не объявлен в **той** области. Вместо этого будет создана или перезаписана *глобальная* переменная `count` (_прим. перев._ — замена кода внутри `foo.hack` на `this.count = 1337`, не поможет, конечно же, тоже, поскольку `count` никогда не был свойством объекта `Counter`, а был лишь внутренней переменной);

### Замыкания внутри циклов

Существует одна, довольно часто встречающаяся, ловушка — когда замыкания используют внутри циклов, передавая переменную индекса внутрь.

    for(var i = 0; i < 10; i++) {
        setTimeout(function() {
            console.log(i);
        }, 1000);
    }

Данный код **не** будет выводить числа с `0` до `9` — вместо этого число `10` будет выведено десять раз.

*Анонимная* функция сохраняет лишь **ссылку** на `i`, и когда будет вызвана функция `console.log`, цикл `for` уже *закончит* свою работу — и поэтому в переменной `i` будет покоиться значение `10`.

Для получения желаемого результата необходимо создать **копию** переменной `i`.

### Обход проблемы со ссылкой

Для того, чтобы скопировать значение индекса из цикла, лучше всего использовать другую [анонимную функцию](#function.scopes) как обёртку.

    for(var i = 0; i < 10; i++) {
        (function(e) {
            setTimeout(function() {
                console.log(e);
            }, 1000);
        })(i);
    }

Анонимная функция-обертка вызывается сразу же, и в качестве первого аргумента получает индекс `i`, **значение** которого будет скопировано в параметр `e`.

Анонимная функция, которая передается в `setTimeout`, теперь содержит ссылку на переменную `e`, значение которой **не** изменяется циклом.

Этот приём можно реализовать и другим способом — возвратив нужную функции из анонимной функции-обертки — поведение такого кода будет идентично поведению кода из предыдущего примера.

    for(var i = 0; i < 10; i++) {
        setTimeout((function(e) {
            return function() {
                console.log(e);
            }
        })(i), 1000)
    }

_Прим, перев._ В качестве упражнения на замыкания и анонимные функции, попробуйте заменить оборачивающие вызовы анонимных функций в примерах на варианты с `.call` и `.apply`.

> **Замечание** от перев. Переменную `e` можно тоже назвать `i`, если вы хотите: это не поменяет поведения кода — внутренняя переменная `i` всё так же будет *копией* внешней переменной.

