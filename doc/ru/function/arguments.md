## Объект `arguments`

В области видимости любой функции в JavaScript есть доступ к специальной переменной `arguments`. Эта переменная содержит в себе список всех аргументов, переданных данной функции.

> **Замечание:** В случае, если переменная `arguments` уже была объявлена в области видимости функции либо путём присвоения через выражение `var`, либо являясь формальным параметром, объект `arguments` не будет создан.

Объект `arguments` **не** является ни экземпляром, ни наследником `Array`. Он, конечно же, очень похож на массив, и даже обладает свойством `length` — но он не наследует `Array.prototype`, и если внимательно присмотреться, он окажется обычным `Object`.

По этой причине, у объекта `arguments` **отсутствуют** стандартные методы массивов, такие как `push`, `pop` или `slice`. Пусть перебор с использованием обычного цикла `for` по аргументам работает вполне корректно, но вам придётся конвертировать этот объект в настоящий массив типа `Array`, чтобы обрести возможность применять к нему стандартные методы массивов.

### Преобразование в массив

Этот код вернёт новый массив типа `Array`, содержащий все элементы объекта `arguments`.

    Array.prototype.slice.call(arguments);

Будьте внимательны — это преобразование занимает **много времени** и поэтому **не рекомендуется** использовать его в чувствительных к производительности частях кода.

### Передача аргументов

Ниже представлен рекомендуемый способ передачи аргументов из одной функции в другую.

    function foo() {
        bar.apply(null, arguments);
    }
    function bar(a, b, c) {
        // делаем здесь что-нибудь
    }

Другой трюк — использовать и `call` и `apply` вместе, чтобы создать обёртку, отвязанную от объекта, и при этом выполняющуюся приемлемо быстро:

    function Foo() {}

    Foo.prototype.method = function(a, b, c) {
        console.log(this, a, b, c);
    };

    // Создаём несвязанную версию метода
    // Она принимает параметры: this, arg1, arg2...argN
    Foo.method = function() {

        // Результат: Foo.prototype.method.call(this, arg1, arg2... argN)
        Function.call.apply(Foo.prototype.method, arguments);

    };


### Формальные аргументы и индексы аргументов

Объект `arguments` создаёт по одному *геттеру* и по одному *сеттеру* как для всех своих свойств, так и для формальных параметров функции.

В результате, изменение формального параметра повлечёт за собой изменение значения соответствующего свойства объекта `arguments` и наоборот.

    function foo(a, b, c) {
        arguments[0] = 2;
        a; // 2

        b = 4;
        arguments[1]; // 4

        var d = c;
        d = 9;
        c; // 3
    }
    foo(1, 2, 3);

### Разоблачение мифов о производительности

Объект `arguments` создаётся во всех случаях, за одним лишь исключением — когда он переопределён по имени внутри функции, или когда одним из её параметров является переменная с таким именем. При этом ееважно, используется ли сам объект в коде функции или нет.

*Геттеры* и *сеттеры* создаются **всегда**; так что их использование практически никак не влияет на производительность, и тем более никак не влияет на неё в реальном коде, где обычно происходят вещи посерьёзнее обычных прочтений и переопределений свойств объекта `arguments`.

> **Замечание по ES5:** Эти *геттеры* и *сеттеры* не создаются в strict-режиме.

Однако, есть одна такая тайна, что её незнание может радикально понизить производительность кода в современных движках JavaScript. Эта тайна — опасность использования `arguments.callee`.

    function foo() {
        arguments.callee; // сделать что-либо с этим объектом функции
        arguments.callee.caller; // и с вызвавшим его объектом функции
    }

    function bigLoop() {
        for(var i = 0; i < 100000; i++) {
            foo(); // должна была бы «развернуться»
        }
    }

В коде выше, функция `foo` не может [быть «развёрнута»][1] (а могла бы), потому что для корректной работы ей необходима ссылка как на себя, так и на вызвавший её объект. Такой код не только кладёт на лопатки механизм развёртывания, но и нарушает принцип инкапсуляции, поскольку функция становится зависима от конкретного контекста вызова.

**Крайне не рекомендуется** использовать `arguments.callee` или какое-либо из его свойств. **Никогда**.

> **Замечание по ES5:** В strict-режиме любое использование `arguments.callee` вызовет `TypeError`, поскольку свойство принято устаревшим.

[1]: http://en.wikipedia.org/wiki/Inlining

