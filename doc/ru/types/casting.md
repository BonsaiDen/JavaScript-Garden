## Приведение типов

JavaScript — *слабо типизированный* язык, поэтому *преобразование типов* будет применяться **везде**, где возможно.

    // Эти равенства — истинны
    new Number(10) == 10; // Number.toString() преобразуется
                          // обратно в число

    10 == '10';           // Strings преобразуется в Number
    10 == '+10 ';         // Ещё чуток строко-безумия
    10 == '010';          // и ещё
    isNaN(null) == false; // null преобразуется в 0,
                          // который конечно же не NaN

    // Эти равенства — ложь
    10 == 010;
    10 == '-10';

> **ES5 Замечание:** Числовые литералы, которые начинаются с 0, интерпретируются как восьмеричные (Base 8). В ECMAScript 5 strict mode **удалена** поддержка восьмеричной системы.

Для того, чтобы избежать этого, **настоятельно** рекомендуется использовать [оператор строгого равенства](#types.equality). Впрочем, хотя это и позволяет избежать многих распространенных ошибок, существует ещё много дополнительных вопросов, которые возникают из-за слабости типизации JavaScript.

### Конструкторы встроенных типов

Конструкторы встроенных типов, например, `Number` и `String` ведут себя различным образом, в зависимости от того, вызываются они с ключевым словом `new` или без.

    new Number(10) === 10;     // False, Object и Number
    Number(10) === 10;         // True, Number и Number
    new Number(10) + 0 === 10; // True, из-за неявного преобразования

Использование встроенного типа, такого как `Number`, в качестве конструктора создаёт новый экземпляр объекта Number, но при использовании без ключевого слова `new` функция `Number` будет вести себя как конвертер.

Кроме того, присутствие литералов или переменных, которые не являются объектами, приведет к еще большему насилию над типами.

Лучший вариант — это **явное** приведение к одному из трех возможных типов.

### Приведение к строке

    '' + 10 === '10'; // true

Путём добавления в начале пустой строки, значение легко приводится к строке.

### Приведение к числовому типу

    +'10' === 10; // true

Используя **унарный** оператор плюс, можно преобразовать значение в число.

### Приведение к булеву типу

Используя оператор **not** (**`!`**) дважды, значение может быть приведено к логическому (булеву) типу.

    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true

