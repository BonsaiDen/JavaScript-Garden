## Приведение типов

JavaScript — язык, в котором господствует *слабая типизация*, поэтому *преобразование типов* будет применяться **везде**, где только возможно.

    // Эти равенства возвращают true
    new Number(10) == 10; // объект типа Number преобразуется
                          // в числовой примитив в результате неявного вызова
                          // метода Number.prototype.valueOf

    10 == '10';           // Строки преобразуются в Number
    10 == '+10 ';         // Ещё чуток строко-безумия
    10 == '010';          // и ещё
    isNaN(null) == false; // null преобразуется в 0,
                          // который, конечно же, не NaN

    // Эти равенства возвращают false
    10 == 010;
    10 == '-10';

> **ES5 Замечание:** Числовые литералы, которые начинаются с 0, интерпретируются как восьмеричные (Base 8). В ECMAScript 5 strict mode **удалена** поддержка восьмеричной системы.

Для того, чтобы избежать такого поведения, **настоятельно** рекомендуется использовать [оператор строгого равенства](#types.equality). Впрочем, хотя это и позволяет избежать многих распространенных ошибок, существует ещё много дополнительных проблем, возникающих по вине слабой типизации JavaScript.

### Конструкторы встроенных типов

Конструкторы встроенных типов, например, `Number` и `String` ведут себя различным образом, в зависимости от того, вызываются они с ключевым словом `new` или без.

    new Number(10) === 10;     // False: Object и Number
    Number(10) === 10;         // True: Number и Number
    new Number(10) + 0 === 10; // True: из-за неявного преобразования

Использование встроенных типов, таких как `Number`, с конструктором, создаёт новый экземпляр объекта `Number`, но использование их же без ключевого слова `new`, создаёт функцию `Number`, которая будет вести себя в равенствах в роли «преобразователя».

Кроме того, присутствие в равенствах дополнительных литералов или переменных, которые не являются объектами, повлечёт за собой лишь ещё больше ненужных преобразований типов.

Лучший вариант — это **явное** приведение к одному из трех возможных типов.

### Приведение к строке

    '' + 10 === '10'; // true

Путём добавления в начало пустой строки, значение легко приводится к строке.

### Приведение к числовому типу

    +'10' === 10; // true

Применив **унарный** оператор плюс, можно преобразовать значение в число.

### Приведение к булеву типу

Использование оператора **not** (`!`) дважды поможет привести значение к логическому (булеву) типу.

    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true

