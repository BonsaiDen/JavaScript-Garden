## Великий Прототип

В JavaScript отсутствует классическая модель наследования — вместо неё используется [*прототипная модель*][1].

Хоть её и часто причисляют к недостаткам JavaScript, на самом деле прототипная модель наследования *мощнее* классической. К примеру, поверх неё можно предельно легко реализовать классическое наследование, а попытки совершить обратное непременно вынудят вас попотеть.

Из-за того, что JavaScript — практически единственный широко используемый язык с прототипным наследованием, придётся потратить некоторое время на осознание различий между этими двумя моделями.

Первое важное отличие заключается в том, что наследование в JavaScript выполняется с использованием так называемых  *цепочек прототипов*.

> **Замечание:** При использовании конструкции `Bar.prototype = Foo.prototype` оба объекта будут делить друг с другом **один и тот же** прототип. Так что изменение прототипа одного из объектов повлечёт за собой изменение прототипа другого и наоборот — вряд ли это то, чего вы ожидали.

    function Foo() {
        this.value = 42;
    }
    Foo.prototype = {
        method: function() {}
    };

    function Bar() {}

    // Установим значением прототипа Bar новый экземпляр Foo
    Bar.prototype = new Foo();
    Bar.prototype.foo = 'Hello World';

    // Убедимся, что Bar является настоящим конструктором
    Bar.prototype.constructor = Bar;

    var test = new Bar() // создадим новый экземпляр bar

    // Цепочка прототипов, которая получится в результате
    test [instance of Bar]
        Bar.prototype [instance of Foo]
            { foo: 'Hello World' }
            Foo.prototype
                { method: ... }
                Object.prototype
                    { toString: ... /* и т.д. */ }

В приведённом коде объект `test` будет наследовать оба прототипа: `Bar.prototype` и `Foo.prototype`; следовательно, у него будет доступ к функции `method`, которую мы определили в прототипе `Foo`. Также, у него будет доступ к свойству `value` **одного уникального** экземпляра `Foo`, который является его прототипом. Важно заметить, что `new Bar()` при вызове **не создаёт** новый экземпляр `Foo`, а повторно использует тот объект, который был установлен ему (`Bar`) в прототипе: таким образом, все новые экземпляры `Bar` будут иметь **одно и то же** свойство `value` (_прим. перев._ — то есть, все ссылки по имени `value`, во всех экземплярах `Bar`, будут указывать на одно и то же место в памяти).

> **Замечание:** Никогда **не используйте** конструкцию `Bar.prototype = Foo`, поскольку ссылка будет указывать не на прототип `Foo`, а на объект-функцию `Foo`. Из-за этого цепочка прототипов будет проходить через `Function.prototype`, а не через `Foo.prototype`, в результате чего функция `method` вообще не будет содержаться в цепочке прототипов.

### Поиск свойств

При обращении к какому-либо свойству объекта, движок JavaScript проходит **вверх** по цепочке прототипов этого объекта, пока не найдет свойство c запрашиваемым именем.

Если он достигнет верхушки этой цепочки (а именно `Object.prototype`), и при этом так и не найдёт указанное свойство, вместо него вернётся значение [undefined](#core.undefined).

### Свойство `prototype`

Тот факт, что свойство `prototype` используется языком для построения цепочек прототипов, даёт нам возможность присвоить **любое** значение этому свойству. Впрочем, обычные примитивы, если назначать их в качестве прототипов, будут просто-напросто игнорироваться.

    function Foo() {}
    Foo.prototype = 1; // никакого эффекта
    Foo.prototype = {
        "foo":"bar"
    }; // это сработает

Но присвоение объектов, как в примерах здесь и выше, работает, и позволяет вам создавать цепочки прототипов динамически.

### Производительность

Поиск свойств, располагающихся относительно высоко по цепочке прототипов, может негативно сказаться на производительности, особенно в критических к ней местах кода. Если же мы попытаемся найти несуществующее свойство, то поиск будет осуществлён вообще по всей цепочке, со всеми вытекающими последствиями.

Вдобавок, при [циклическом переборе](#object.forinloop) свойств объекта, будет обработано **каждое** свойство, существующее в цепочке прототипов.

### Расширение встроенных прототипов

Часто встречается неверное применение прототипов — расширение прототипа `Object.prototype` или прототипов одного из встроенных объектов JavaScript.

Подобная практика нарушает принцип *инкапсуляции*, и имеет соответствующее название — [monkey patching][2]. К сожалению, в основу многих широко распространенных фреймворков, например Prototype, положен принцип изменения базовых прототипов. На самом деле — до сих пор не известно разумных причин примешивать во встроенные типы *нестандартную функциональность*.

**Единственным** оправданием для расширения встроенных прототипов может быть только воссоздание возможностей более новых движков JavaScript, например функции [`Array.forEach`][4], которая появилась в версии 1.6.

### Заключение

Перед тем, как вы приступите к разработке сложных приложений на JavaScript с использованием прототипов, вы **должны** полностью осознать как работают прототипные цепочки, и как организовывать наследование на их основе. Также, помните о зависимости между длиной цепочек прототипов и производительностью — разрывайте их при необходимости. Кроме того — **никогда** не расширяйте прототипы встроенных объектов, если вы не делаете это для совместимости с новыми возможностями Javascript.

[1]: http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5
[2]: http://en.wikipedia.org/wiki/Monkey_patch
[3]: http://prototypejs.org/
[4]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach

