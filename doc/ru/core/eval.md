## Почему нельзя использовать `eval`

Функция `eval` выполнит переданную строку в качестве кода JavaScript в локальной области видимости:

    var foo = 1;
    function test() {
        var foo = 2;
        eval('foo = 3');
        return foo;
    }
    test(); // 3
    foo; // 1

но только тогда, когда функция `eval` вызывается явно *и при этом* имя вызываемой функции *идентично* `eval`:

    var foo = 1;
    function test() {
        var foo = 2;
        var bar = eval;
        bar('foo = 3');
        return foo;
    }
    test(); // 2
    foo; // 3

**Любой ценой** избегайте функции `eval`. 99.9% «трюков» с её «использованием» могут быть запросто решены и **без её участия**.

### `eval` под прикрытием

Обе [функции работы с интервалами времени](#other.timeouts) `setTimeout` и `setInterval` могут принимать строку в качестве первого аргумента. Эта строка **всегда** будет выполняться в глобальной области видимости, поскольку `eval` в этом случае вызывается *неявно*.

### Проблемы с безопасностью

Кроме всего прочего, функция `eval` — это дыра в безопасности, поскольку она выполняет **любой** переданный в неё код; **никогда** не используйте её со строками из неизвестных или недоверительных источников.

### Заключение

Никогда не используйте `eval`: любой код с участием этой функции автоматически порождает вопросы о качестве его работы, производительности и безопасности. Если вдруг для работы вам необходим `eval`, эта часть кода должна тут же ставиться под сомнение и в первую очередь *исключаться* из проекта — необходимо найти *лучший способ*, которому не требуются вызовы `eval`.

