## Почему нельзя использовать `eval`

Функция `eval` исполняет хранящийся в строке код JavaScript в локальной области видимости.

    var foo = 1;
    function test() {
        var foo = 2;
        eval('foo = 3');
        return foo;
    }
    test(); // 3
    foo; // 1

Однако, `eval` исполняется в локальной области видимости тогда и только тогда, когда он вызывается явно *и при этом* имя вызывающейся функции идентично `eval` (''прим. перев.'' — ох!).

    var foo = 1;
    function test() {
        var foo = 2;
        var bar = eval;
        bar('foo = 3');
        return foo;
    }
    test(); // 2
    foo; // 3

**Любой ценой** избегайте использования функции `eval`. 99.9% «трюков» с её «использованием» могут легко решаться и **без её участия**.

### `eval` под прикрытием

Обе [функции работы с интервалами времени](#other.timeouts) `setTimeout` и `setInterval` могут принимать строку в качестве первого аргумента. Эта строка **всегда** будет выполняться в глобальной области видимости, поскольку `eval` в этом случае вызывается *неявно*.

### Проблемы с безопасностью

Кроме всего прочего, функция `eval` — это проблема в безопасности, поскольку она выполняет **любой** переданный в неё код; **никогда** не следует использовать её со строками из неизвестных или недоверительных источников.

### Заключение

Использовать `eval` не стоит никогда: любой код с участием этой функции автоматически порождает вопросы о качестве его работы, производительности и безопасности. Если вдруг для работы вам необходим `eval`, эта часть кода должна тут же ставиться под сомнение и в первую очередь *исключаться** из проекта — необходимо найти *лучший способ*, которому не требуются вызовы `eval`.

