### `setTimeout` и `setInterval`

В виду того, что JavaScript умеет совершать асинхронные операции, есть возможность запланировать отложенное выполнение пользовательской функции, используя предназначенные для этого функции `setTimeout` и `setInterval`.

> **Замечание:** Таймауты **не** являются частью стандарта ECMAScript, они были разработаны будучи частью спецификации[DOM][1].

    function foo() {}
    var id = setTimeout(foo, 1000); // возвращает число > 0

Функция `setTimeout` возвращает идентификатор назначенного таймаута и откладывает вызов `foo` на, **примерно**, тысячу миллисекунд. Фунция `foo`, при этом, будет вызвана только **один** раз.

В зависимости от разрешения таймера в используемом для запуска кода движке JavaScript, а также с учётом того, что JavaScript является однопоточным языком и посторонний код может заблокировать выполнение потока, нет **никакой** гарантии, что переданный код будет выполнен ровно через указанное в вызове `setTimeout` время.

Функция, переданная первым параметром, будет вызвана в контексте *глобального объекта* — это значит, что оператор [`this`](#function.this) в вызываемой функции будет ссылаться на тот самый глобальный объект.

    function Foo() {
        this.value = 42;
        this.method = function() {
            // this ссылается на глобальный объект
            console.log(this.value); // выведет в лог undefined
        };
        setTimeout(this.method, 500);
    }
    new Foo();


> **Замечание:** Поскольку `setTimeout` принимает **объект функции** в качестве первого параметра, часто совершается ошибка в использовании `setTimeout(foo(), 1000)`, при котором будет использоваться **возвращённое значение** от вызова функции `foo`, а **не** вызываться сама функция `foo`. В большинстве случаев ошибка пройдёт незамеченной, а в случае если функция возвращает `undefined`, `setTimeout` вообще **не** породит никакой ошибки.

### Очереди вызовов с `setInterval`

`setTimeout` вызывает функцию единожды; `setInterval` — как и предполагает название — вызывает функцию **каждые** `X` миллисекунд. И использовать его не рекомендуется.

В то время как, если применять `setTimeout`, исполняющийся в данный момент код будет блокировать запланированный — `setInterval` будет продолжать планировать последующие вызовы переданной функции. Это может, особенно при указании небольших интервалов, повлечь за собой выстраивание функций в ожидающую очередь.

    function foo(){
        // что-то, выполняющееся одну секунду или более
    }
    setInterval(foo, 1000);

В приведённом примере `foo` в первый же раз заблокирует своим процессом главный поток на одну секунду.

Пока `foo` блокирует код, `setInterval` продолжает планировать последующие её вызовы. Теперь, когда первая `foo` закончила выполнение, в очереди будут уже **десять** ожидающих выполнения вызовов `foo`.

### Разбираемся с потенциальной блокировкой кода

Самый простой и наиболее легко контролируемый способ — использовать `setTimeout` внутри такой функции.

    function foo(){
        // что-то, выполняющееся одну секунду или более
        setTimeout(foo, 1000);
    }
    foo();

Такой способ не только инкапсулирует вызов `setTimeout`, но и предотвращает от очередей блокирующих вызовов и при этом обеспечивает дополнительный контроль. Сама функция `foo` теперь принимает решение, хочет ли она запускаться ещё раз или нет.

(''прим. перев.'' — такая техника теперь активно используется при использовании браузерного метода `requestAnimationFrame` для анимации, работающей на `canvas`).

### Сброс таймаутов вручную

Удалить таймаут или интервал можно посредством передачи соответствующего идентификатора либо в функцию `clearTimeout`, либо в функцию `clearInterval` — в зависимости от того, какая функция `set...` использовалась для его создания.

    var id = setTimeout(foo, 1000);
    clearTimeout(id);

### Сброс всех таймаутов

Из-за того, что встроенного метода для удаления всех созданных таймаутов и/или интервалов не существует, для успешного достижения этой цели приходится использовать силу.

    // сбрасываем «все» таймауты
    for(var i = 1; i < 1000; i++) {
        clearTimeout(i);
    }

Впрочем, с таким кодом, вполне могут остаться «живыми» таймауты, которые не окажутся охвачены настолько произвольным числом.

Есть и другой способ воплотить желаемое — условиться, что значения ID, выдающихся таймаутам, постоянно увеличиваются — с каждым новыми вызовом `setTimeout`.

    // сбрасываем «все» таймауты
    var biggestTimeoutId = window.setTimeout(function(){}, 1),
    i;
    for(i = 1; i <= biggestTimeoutId; i++) {
        clearTimeout(i);
    }

Однако, даже при том, что такой код работает сегодня во всех современных браузерах, нигде не указано и не гарантируется, что значения ID всегда увеличиваются. Поэтому, всё же, рекомендуется следить за *каждым* идентификатором *каждого* создающегося таймаута —  это позволит вам надёжно контролировать процесс, сбрасывая их индивидуально.

### Скрытое использование `eval`

`setTimeout` и `setInterval` могут принимать строку в качестве первого параметра. Эту возможность не стоит использовать **никогда**, поскольку изнутри, при этом, производится скрытый вызов `eval`.

> **Замечание**: Поскольку функции работы с таймаутами **не** определены в стандарте ECMAScript, точная внутренняя механика их работы может различаться от движка к движку. Например, Microsoft JScript использует конструктор `Function` вместо `eval`.

    function foo() {
        // будет вызвана
    }

    function bar() {
        function foo() {
            // никогда не будет вызывана
        }
        setTimeout('foo()', 1000);
    }
    bar();

Поскольку `eval` в этом случае не вызывается [явно](#core.eval), переданная в `setTimeout` строка будет выполнена в *глобальной области видимости*; так что локальная функция `foo` из области видимости `bar` вообще не будет выполнена.

По этим же причинам **не рекомендуется** использовать строковое представление вызова функции для передачи аргументов в функцию, которая должна быть вызвана посредством любого из двух известных способов назначения таймаутов.

    function foo(a, b, c) {}

    // НИКОГДА не делайте такого
    setTimeout('foo(1,2, 3)', 1000)

    // Вместо этого используйте анонимную функцию
    setTimeout(function() {
        foo(a, b, c);
    }, 1000)

> **Замечание:** При том, что практически возможно использовать синтаксис `setTimeout(foo, 1000, a, b, c)`, делать это крайне не рекомендуется, поскольку может привести к трудно-отлавливаемым ошибкам при операциях с [методами](#function.this).

### Заключение

**Никогда** не используйте строки как параметры для `setTimeout` или `setInterval`. Это явный признак **действительно** плохого кода. Если вызываемой функции необходимо передавать аргументы, лучше передавать *анонимную функцию*, которая самостоятельно будет отвечать за сам вызов.

Кроме прочего, избегайте использования `setInterval` в случаях, когда его планировщик может заблокировать выполнение основного кода JavaScript.

[1]: http://ru.wikipedia.org/wiki/Document_Object_Model "Document Object Model"

