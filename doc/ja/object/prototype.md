## プロトタイプ

JavaScriptはクラスベース継承モデルは実装されておらず、この代わりに*プロトタイプ*を用いています。

プロトタイプモデルを使っている事が、JavaScriptの弱点の一つになっていると良く考えられがちですが、プロトタイプ継承モデルはクラスベース継承モデルよりパワフルだというのは事実です。この事はちょっとしたものでもクラスベースの継承で実装しようとすると、プロトタイプベースの継承よりも作業が難しくなるという事でも分かります。

JavaScriptはプロトタイプベースが採用されている唯一の広範に使用されている基本的なプログラミング言語という現実があるので、プロトタイプベースとクラスベースの違いを時々調整しないとなりません。

最初の大きな違いはJavaScriptの継承は*プロトタイプチェーン*と呼ばれるもので実行されているという事です。

> **注意:** 単に`Bar.prototype = Foo.prototype`を使った場合、両方のオブジェクトは、
> **同じ**プロトタイプを共有する事になります。その為、片方のオブジェクトのプロトタイプの変更は
> もう一方のオブジェクトに影響します。殆どの場合、このような影響を及ぼしたく無いと思います。

    function Foo() {
        this.value = 42;
    }
    Foo.prototype = {
        method: function() {}
    };

    function Bar() {}

    // BarのプロトタイプをFooの新しいインスタンスとしてセットする
    Bar.prototype = new Foo();
    Bar.prototype.foo = 'Hello World';

    // Barを実際のコンストラクタとして確実にする為に代入する
    Bar.prototype.constructor = Bar;

    var test = new Bar() // 新しくbarインスタンスを作成

    // プロトタイプチェーンの結果
    test [instance of Bar]
        Bar.prototype [instance of Foo] 
            { foo: 'Hello World', value: 42 }
            Foo.prototype
                { method: ... }
                Object.prototype
                    { toString: ... /* その他 */ }

上記では`test`は`Bar.prototype`と`Foo.prototype`の2つのオブジェクトより継承されます。その為`Foo`の中で設定された`method`関数にアクセスできるようになります。また、`Foo`のプロトタイプとしてのインスタンス**それ自体**の`value`プロパティにもアクセスが可能です。`new Bar()`は`Foo`のインスタンスを新しく作**りません**が、プロトタイプに割り合てられた`Foo`インスタンスを再利用している事は注目に値します。従って全ての`Bar`インスタンスは**同じ**`value`プロパティを共有します。

> **注意:** `Bar.prototype = Foo`のような使い方は**しない**で下さい。`Foo`はそのプロトタイプではなく、
> 関数オブジェクト`Foo`自体を指しているからです。
> プロトタイプチェーンは`Foo.prototype`ではなく`Function.prototype`まで遡るので、
> `method`はプロトタイプチェーン上に出現しなくなります。

### プロパティ探索

オブジェクトのプロパティにアクセスする時には、JavaScriptはプロトタイプチェーンを要求された名前を見つけるまで**遡って**探索します。

チェーンの先頭(すなわち`Object.prototype`)に到達した際に、まだ指定されたプロパティが見つからなければ、代わりに[undefined](#core.undefined)という値を返します。

### プロトタイププロパティ

プロトタイププロパティはJavaScriptの中でプロトタイプチェーンを構築する為に使われていますが、**任意**の値を代入する事も可能になっています。しかし、プロトタイプとしてプリミティブが代入された場合は単に無視されるだけです。

    function Foo() {}
    Foo.prototype = 1; // 効果無し

オブジェクトの代入は上記の例のように動作し、動的にプロトタイプチェーンを作る事ができます。

### パフォーマンス

プロトタイプチェーンの上位にあるプロパティを探索する時間はコードの実行パフォーマンスに重大な悪影響を与えます。特に存在しないプロパティにアクセスしようとすると、プロトタイプチェーンの全てのプロパティを探索してしまいます。

また、オブジェクトのプロパティに対して[反復](#object.forinloop)処理をすると、プロトタイプチェーン上の**全て**のプロパティを列挙してしまいます。


### 既存のプロトタイプの拡張

元々組み込まれてるプロトタイプや`Object.prototype`を拡張するのは、良くありがちなイケていない実装方法になります。

このテクニックは[monkey patching][1]と呼ばれるもので*カプセル化*を壊してしまいます。このテクニックは[Prototype][2]のようなフレームワークにより広まりましたが、*非標準*の機能を持っている組み込み型のオブジェクトの乱立という点でも推奨されません。

**唯一**組み込みのプロトタイプを拡張しても良い理由としては、JavaScriptエンジンに将来実装されるであろう機能の移植だけです。
例えば[`Array.forEach`][3]などが、それに当たります。

### 終わりに

ここまでがプロトタイプベース継承モデルを使って複雑なコードを書く前に**必ず**理解すべき事です。また、プロパティチェーンの長さを観察して、もしパフォーマンスに悪影響を及ぼすのを防ぐ為ならば、これを分割をしなければなりません。さらに組み込みのプロトタイプは新しいJavaScriptの機能と互換性が無い限りは**絶対**に拡張してはいけません。
[1]: http://en.wikipedia.org/wiki/Monkey_patch
[2]: http://prototypejs.org/
[3]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach

