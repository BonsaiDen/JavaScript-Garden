### `setTimeout`と`setInterval`

JavaScriptは非同期なので、`setTimeout`と`setInterval`関数を使ってある関数の実行のスケジュールを決める事が可能です。

> **注意点:** タイムアウトはECMAScript標準の一部では**ありません**。
> これらは[DOM][1]の一部として実装されています。

    function foo() {}
    var id = setTimeout(foo, 1000); // Number > 0を返す

`setTimeout`が呼ばれた時に、タイムアウトのIDと`foo`この先の**おおよそ**1000msに実行するスケジュールを返します。`foo`は正確に**1度**だけ実行されます。

コードが実行されているJavaScriptエンジンのタイマー分解能によって決まります。この事実はJavaScriptがシングルスレッドのなので、他のスレッドでの実行を妨害してしまう事があるかもしれません。これは、`setTimeout`の呼び出しにより指定された正確なディレイで実行するという確実な賭けという**意味ではありません**。

第一パラメーターを渡された関数は*グローバルオブジェクト*によって呼び出されます。これは呼び出された関数の内部で[`this`](#functionis)がまさにこのオブジェクトを参照しているという事になります。

    function Foo() {
        this.value = 42;
        this.method = function() {
            // これはグローバルオブジェクトを参照しています
            console.log(this.value); // undefinedを記録するはずです
        };
        setTimeout(this.method, 500);
    }
    new Foo();


> **注意点:** `setTimeout`は**関数オブジェクト**を第一引数に取ります。
> 良く間違えてしまう使い方として`setTimeout(foo(), 1000)`というものがあります。
> `foo`と`foo`**以外**の呼び出しに対する**戻り値**としてしまいます。これは、大体において、
> 関数が`undefined`になる為に表に出ないエラーになるでしょう。`setTimeout`はどんな
> エラーも発生`させません`。

### `setInterval`でスタッキングコール

`setTimeout`は関数を一度だけ実行します。`setInterval` - 名前が示すように - **毎回**`X`ミリ秒毎に関数を実行しますが、この使用は推奨されていません。

コードがタイムアウト呼び出しブロックで実行される時に、`setInterval`は指定された関数を呼び出します。これは、特に小さい間隔で、関数の結果をスタックに積む事ができます。

    function foo(){
        // 1秒おきにブロックの何かを実行
    }
    setInterval(foo, 100);

上記のコードでは、`foo`が1回呼び出されて、1秒ブロックされます。

`foo`がコードをブロックしている間、`setInterval`は呼び出される予定を確保しています。`foo`が完了した瞬間に、実行を待っている間に**10回**以上呼び出されている事になります。

### ブロッキング可能なコードの取り扱い

簡単かつ、一番コントロール可能な解決法として、関数自体の中で`setTimeout`を使うという方法があります。

    function foo(){
        // 1秒ブロックする何か
        setTimeout(foo, 100);
    }
    foo();

このカプセル化は`setTimeout`の呼び出しだけでなく、呼び出しのスタッキングを防止してより詳細なコントロールが出来ます。`foo`それ自身が今や、再度実行するかしないかを決める事が出来るのです。

### 手動でタイムアウトをクリアする

タイムアウトとインターバルのクリアは、`clearTimeout`か`clearInterval`に個別のIDを渡せば出来ます。最初に`set`関数を使った場所に依存します。

    var id = setTimeout(foo, 1000);
    clearTimeout(id);

### 全てのタイムアウトをクリアする

全てのタイムアウトや、インターバルをクリアする組み込みメソッドが無い為、機能的にクリアする為には暴力的な手段を使う必要があります。

    // "全ての"タイムアウトをクリアする
    for(var i = 1; i < 1000; i++) {
        clearTimeout(i);
    }

ここまでもまだ、任意の数字を与えられた為に影響を受けないタイムアウトがあるかもしれません。しかし、全てのタイムアウトのIDを追跡していく事は推奨されないので、それらは個別にクリアされます。

### 隠された`eval`の使用

`setTimeout`と`setInterval` は、第一引数に文字列を取る事が可能です。この仕様は内部で`eval`を使用する為に、**絶対に**使うべきではありません。

> **注意点:** タイムアウト関数はECMAScript標準では制定されて**いない**為に
> 文字列を引数にした場合に厳密な動作は色々なJavaScript実装により異なります。
> 例えば、MicrosoftのJScriptは`eval`の代わりに`Function`コンストラクターを
> 使用します。

    function foo() {
        // この先呼ばれる
    }

    function bar() {
        function foo() {
            // 絶対に呼ばれない
        }
        setTimeout('foo()', 1000);
    }
    bar();

この場合、`eval`は[直接](#core.eval)呼ばれないので、文字列が渡された`setTimeout`は*global scope*で実行されます。よって、`bar`のスコープから`foo`のローカル変数は使われないのです。

さらに、文字列を関数に渡さ**ない**ように推奨される理由として、それぞれのタイムアウト関数から呼び出されるという事があります。

    function foo(a, b, c) {}
    
    // 絶対にこのように使わない
    setTimeout('foo(1,2, 3)', 1000)

    // 匿名関数を代わりに使用する
    setTimeout(function() {
        foo(a, b, c);
    }, 1000)

> **注意点:** `setTimeout(foo, 1000, a, b, c)`のようなシンタックスを使用する事も
> できますが、[メソッド](#function.this)を使用した際に、分かりにくいエラーが起りえるので
> 使用はお勧めしません。

### 終りに

`setTimeout`や`setInterval`のパラメーターに文字列を使用する事は**絶対**するべきではありません。引数が関数に呼び出される必要がある場合**本当**に悪いコードの明確なサインになります。実際の呼び出しには*匿名関数*を渡すべきです。

その上で、`setInterval`の使用はそのスケジューラーがJavaScriptの実行をブロックするので避けるべきでしょう。

[1]: http://en.wikipedia.org/wiki/Document_Object_Model "Document Object Model"

