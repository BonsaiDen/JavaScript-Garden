## 型変換

JavaScriptは*弱い型付け*の言語なので、可能な**限り**に*型強制*が適用されます。

    // これらはtrueです。
    new Number(10) == 10; // Number.toString()が変換される
                          // numberに戻る

    10 == '10';           // StringsがNumberに変換される
    10 == '+10 ';         // バカみたいに文字列を追加
    10 == '010';          // もっともっと
    isNaN(null) == false; // nullが0に変換される
                          // もちろんNaNではないです

    // これらはfalseです
    10 == 010;
    10 == '-10';

> **ES5での注意点:** `0`から始まるNumberリテラルは8進数(基数が8)として解釈されます。
> このような8進数のサポートはECMAScript5のstrict modeでは**削除されました**。

上記の自体を避ける為に、[厳密等価演算子](#types.equality)を使用する事を**強く**推奨します。また、これはたくさんある落し穴を避けますが、それでもまだJavaScriptの弱い型付けシステムから発生する色々な課題が残っています。

### 組み込み型のコンストラクタ

`Number`や`String`のような組み込み型のコンストラクタは、`new`キーワードの有無で振る舞いが違ってきます。

    new Number(10) === 10;     // False, ObjectとNumber
    Number(10) === 10;         // True, NumberとNumber
    new Number(10) + 0 === 10; // True, 暗黙の型変換によります

`Number`のような組み込み型をコンストラクタとして使うと、新しい`Number`オブジェクトが作られますが、`new`キーワードを除外すると`Number`関数がコンバーターのように振る舞います。

加えて、リテラルかオブジェトではない値を持っていると、さらに型強制が多くなります。

最良のオプションは以下の3つの方法の内、1つで型を**明示**してキャストする事になります。

### Stringでキャストする

    '' + 10 === '10'; // true

空の文字列の付加により値を簡単に文字列にキャストできます。

### Numberでキャストする

    +'10' === 10; // true

**単項**プラスオペレーターを使うと数字にキャストする事が可能です。

### Booleanでキャストする

**not**オペレーターを2回使うと、値はブーリアンに変換できます。

    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true
