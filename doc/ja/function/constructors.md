## コンストラクタ

JavaScriptのコンストラクタは色々ある他のプログラム言語とは一味違います。`new`キーワードが付いているどんな関数呼び出しも、コンストラクタとして機能します。

コンストラクタ内部では -呼び出された関数の事です- `this`の値は新規に生成された`Object`を参照しています。この**新規**のオブジェクトの[`prototype`](#object.prototype)は、コンストラクタとして起動した関数オブジェクトの`prototype`に設定されています。

もし呼び出された関数が、`return`ステートメントを明示していない場合は、暗黙の了解で`this`の値を -新規のオブジェクトとして- 返します。

    function Foo() {
        this.bla = 1;
    }

    Foo.prototype.test = function() {
        console.log(this.bla);
    };

    var test = new Foo();

上記は、`Foo`をコンストラクタとして呼び出し、新規に生成されたオブジェクトの`prototype`を`Foo.prototype`に設定しています。

明示的に`return`ステートメントがある場合、関数は返り値が`Object`である場合に**限り**ステートメントで明示した値を返します。

    function Bar() {
        return 2;
    }
    new Bar(); // 新しいオブジェクト

    function Test() {
        this.value = 2;

        return {
            foo: 1
        };
    }
    new Test(); // 返ってきたオブジェクト

`new`キーワードが省略されている場合は、関数は新しいオブジェクトを返す事は**ありません**。

    function Foo() {
        this.bla = 1; // グローバルオブジェクトに設定される
    }
    Foo(); // undefinedが返る

JavaScriptの[`this`](#function.this)の働きのせいで、上記の例ではいくつかのケースでは動作するように見える場合がありますが、それは*グローバルオブジェクト*が`this`の値として使用されるからです。

### ファクトリー

`new`キーワードを省略するためには、コンストラクタ関数が明示的に値を返す必要があります。

    function Bar() {
        var value = 1;
        return {
            method: function() {
                return value;
            }
        }
    }
    Bar.prototype = {
        foo: function() {}
    };

    new Bar();
    Bar();

`Bar`で呼び出されたものは両方とも全く同じものものになります。これには、`method`と呼ばれるプロパティを持ったオブジェクトが新しく生成されますが、これは[クロージャ](#function.closures)です。

また、注意する点として呼び出された`new Bar()`は返ってきたオブジェクトのプロトタイプに影響**しません**。プロトタイプは新しく生成されたオブジェクトにセットされはしますが、`Bar`は絶対にその新しいオブジェクトを返さないのです。

上記の例では、`new`キーワードの使用の有無は機能的に違いがありません。


### ファクトリーとして新しくオブジェクトを作成する

多くの場合に推奨される事として、`new`の付け忘れによるバグを引き起こしやすいので、`new`を使用**しない**ようにするという事があります。

新しいオブジェクトを作成するためにファクトリーを使用して、そのファクトリー内部に新しいオブジェクトを作成すべきだという事です。

    function Foo() {
        var obj = {};
        obj.value = 'blub';

        var private = 2;
        obj.someMethod = function(value) {
            this.value = value;
        }

        obj.getPrivate = function() {
            return private;
        }
        return obj;
    }

上記の例では`new`キーワードが無いため堅牢になりますし、確実に[プライベート変数](#function.closures)を使用するのが簡単になりますが、いくつかの欠点があります。

 1. 作られたオブジェクトがプロトタイプ上のメソッドを共有しないために、よりメモリーを消費してしまいます。
 2. ファクトリーを継承するために、他のオブジェクトの全てのメソッドをコピーする必要があるか、新しいオブジェクトのプロトタイプ上にそのオブジェクトを設置する必要があります。
 3. `new`キーワードが無いという理由だけで、プロトタイプチェーンから外れてしまうのは、どことなく言語の精神に反します。

### 終わりに

`new`キーワードが省略される事によりバグの可能性がもたらされますが、それによりプロトタイプを全く使わないという確かな理由には**なりません**。最終的には、アプリケーションの必要性により、どちらの解決法がより良いかが決まってきます。特に大切なのは、オブジェクトの作成に特定のスタイルを選ぶ事、また**そのスタイルに固執する事**です。


