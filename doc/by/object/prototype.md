## Прататып

JavaScript не прадастаўляе класічную мадэль спадкаемства; замест гэтага, ён
выкарыстоўвае *прататыпную* мадэль.

Негледзячы на тое, што гэта лічыцца адной з слабасцяў JavaScript, мадэль
прататыпнага спадкаемства больш эфэктыўная за класічную.
Напрыклад, даволі трывіальна пабудаваць класічную мадэль паверх прататыпнай мадэлі,
у той час як адваротнае было б значна больш складаным.

JavaScript гэта адзіная шырока выкарыстоўваемая мова, якая падтрымлівае
прататыпнае спадкаемства, таму можа спатрэбіцца час, каб прызвычаіцца да гэтай мадэлі.

Першая вялікая розніца заключаецца ў тым, што JavaScript выкастроўвае *прататыпныя
ланужкі*.

> **Заўвага:** простае выкарыстоўванне `Bar.prototype = Foo.prototype` прывядзе
> да таго, што абодва аб'екта будуць выкарыстоўваць **той жа** прататып.
> Такім чынам, змены ў прататыпе любога з аб'ектаў паўплываюць на прататып іншага,
> што звычайна не ёсць пажаданым эфэктам.

    function Foo() {
        this.value = 42;
    }
    Foo.prototype = {
        method: function() {}
    };

    function Bar() {}

    // Пазначае прататыпам Bar новы асобнік Foo
    Bar.prototype = new Foo();
    Bar.prototype.foo = 'Hello World';

    // Упэнімся, што Bar з'яўляецца дзейсным канструктарам
    Bar.prototype.constructor = Bar;

    var test = new Bar(); // стварае новы асобнік Bar

    // Выніковы ланцужок прататыпаў
    test [instance of Bar]
        Bar.prototype [instance of Foo]
            { foo: 'Hello World', value: 42 }
            Foo.prototype
                { method: ... }
                Object.prototype
              { toString: ... /* і г.д. */ }

У вышэй прыведзеным кодзе аб'ект `test` атрымае спадчыну і ад `Bar.prototype`,
і ад `Foo.prototype`; такім чынам, ён будзе мець доступ да функцыі `method`, якая
вызначана ў `Foo`. А таксама доступ да ўласцівасці `value`
**аднаго унікальнага асобніка** `Foo`, які з'яўляецца яго прататыпам. Важна заўважыць,
што `new Bar()` **не** стварае новы асобнік `Foo`, але выкарыстоўвае функцыю,
пазначаную яго прататыпам; такім чынам, усе асобнікі `Bar` будуць выкарыстоўваць
**тую ж** уласціваць `value`.

> **Заўвага:** **не** выкарыстоўвайце `Bar.prototype = Foo`, бо гэта будзе
> ўказваць не на прататып `Foo`, а на аб'ект фукцыі `Foo`. Таму ланцужок
> прататыпаў будзе праходзіць праз `Function.prototype`, а не `Foo.prototype`;
> па гэтай прычыне `method` не будзе прысутнічаць у ланцужку прататыпаў.

### Пошук уласцівасцяў

Калі адбываецца зварот да ўласцівасці, JavaScript пройдзе па ўсім
ланцужку прататыпаў **уверх** да таго моманту, як знойдзе ўласціваць з запытаным імем.

У той момант, калі дасягнуты верх ланцужка - а менавіта `Object.prototype` - і ўсё яшчэ
не знойдзена адпаведная ўласцівасць, будзе вернута значэнне [undefined](#core.undefined).

### Уласцівасць prototype

Нягледзячы на тое, што ўласцівасць prototype выкарыстоўваецца мовай, каб пабудаваць
ланцужок прататыпаў, магчыма прызначыць яму **любое** значэнне. Аднак, прызначэнне
прымітываў будузе праігнараваным.

    function Foo() {}
    Foo.prototype = 1; // без эфекту

Прызначэнне аб'ектаў, як паказана ў прыкладзе вышэй, будзе працаваць, і дазволіць
дынамічна ствараць ланцужкі прататыпаў.

### Хуткасць выканання

Пошук уласцівасцяў, якія знаходзяцца высока ў ланцужку прататыпаў, можа
негатыўна адбіцца на хуткасці выканання, і гэта можа быць прыкметным у кодзе, у якім
чыннік хуткасці крытычны. У выпадку спробы доступа да неіснуючых уласцівасцяў
будзе пройдзены ўвесь ланцужок прататыпаў.

У дадатак, пры [ітэрацыі](#object.forinloop) па ўласцівасцях аб'екта
**кожная** уласціваць, што ёсць у ланцужку прататыпаў будзе апрацавана.

### Расшырэнне ўбудаваных прататыпаў

Адна з дрэнных магчымасцяў, што сустракаецца даволі часта — расшырэнне прататыпа
`Object.prototype` або аднаго з іншых убудаваных тыпаў.

Такая практыка называецца [monkey patching][1] і парушае *інкапсуляцыю*. Хаця
папулярныя фрэймворкі, такія як [Prototype][2] шырока выкарыстоўваюць гэтую
мачымасць, няма добрых матываў для нагрувашчвання ўбудаваных тыпаў дадатковай
*нестандартнай* функцыянальнасцю.

**Адзіным** добрым матывам расшырэння убудаваных прататыпаў — гэта дадаванне функцыянала,
што з'явіўся у новых рухавіках JavaScript; напрыклад, [`Array.forEach`][3].

### У завяршэнне

**Вельмі важна** разумець, як працуе мадэль прататыпнага спадкаемства да таго, як
пісаць код, які яе выкарыстоўвае. Таксама сачыце за даўжынёй ланцужка прататыпаў
і драбіце іх, калі ёсць магчымасць, каб пазбегнуць праблем з прадукцыйнасцю.
Таксама ўбудаваныя прататыпы **ніколі** не павінны расшырацца, акрамя як для
таго, каб падтрымаць новыя магчымасці JavaScript.

[1]: http://en.wikipedia.org/wiki/Monkey_patch
[2]: http://prototypejs.org/
[3]: https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach
