## Выкарыстанне і ўласцівасці аб'ектаў

Усё ў JavaScript дзейнічае як аб'ект, апроч двух выключэнняў — гэта
[`null`](#core.undefined) і [`undefined`](#core.undefined).

    false.toString(); // 'false'
    [1, 2, 3].toString(); // '1,2,3'

    function Foo(){}
    Foo.bar = 1;
    Foo.bar; // 1

Часта распрацоўшчыкі думаюць, што лічбавыя літэралы не могуць быць выкарыстаны як
аб'екты. Гэта праз тое, што сінтаксічны аналізатар JavaScript стараецца прывесці
*натацыю кропка* пасля нумара да літэрала з плаваючай кропкай.

    2.toString(); // уздымае SyntaxError

Ёсць некалькі падыходаў, якія могуць дазволіць выкарыстаць лікавыя літэралы як
аб'екты'.

    2..toString(); // другая кропка распазнаецца слушна
    2 .toString(); // заўважце прабел з лева ад кропкі
    (2).toString(); // 2 распазнаецца першым чынам

### Аб'ект як тып дадзеных

Аб'екты ў JavaScript таксама могуць быць выкарыстаныя як [*хэш-табліцы*][1]; яны ў асноўным
складаюцца з іменаваных уласцівасцяў з адпаведнымі значэннямі.

Выкарыстоўваючы натацыю літэрала аб'екта — `{}` — магчыма стварыць
просты аб'ект. Гэты новы аб'ект [пашырае](#object.prototype) `Object.prototype` і
не мае [сваіх уласцівасцяў](#object.hasownproperty) якія былі б вызначыныя.

    var foo = {}; // новы пусты аб'ект

    // новы аб'ект з уласціваццю 'test', якая мае значэнне 12
    var bar = {test: 12};

### Доступ да ўласцівасцяў

Доступ да ўласцівасцяў аб'екта можа быць здейснены двумя спосабамі, праз кропкавую
натацыю або натацыю з квадратнымі дужкамі.

    var foo = {name: 'кацяня'}
    foo.name; // кацяня
    foo['name']; // кацяня

    var get = 'name';
    foo[get]; // кацяня

    foo.1234; // SyntaxError
    foo['1234']; // працуе

Натацыі працуюць амаль што ідэнтычна, з адзінай розніцай у тым, што
натацыя з квадратнымі дужкамі дазваляе дынамічную устаноўку ўласцівасцяў і
выкарыстанне імёнаў уласцівасцяў, якія інакш прывялі б да сінтаксічных памылак.

### Выдаленне ўласцівасцяў

Адзіны спосаб выдаліць уласціваць з аб'екта — гэта выкарыстаць аператар `delete`;
пазначэнне уласціваці як `undefined` або `null` толькі прыбірае
*значэнне* звязанае з уласцівацю, але не *ключ*.

    var obj = {
        bar: 1,
        foo: 2,
        baz: 3
    };
    obj.bar = undefined;
    obj.foo = null;
    delete obj.baz;

    for(var i in obj) {
        if (obj.hasOwnProperty(i)) {
            console.log(i, '' + obj[i]);
        }
    }

Вышэй прыведзены код вывядзе `bar undefined` і `foo null` — толькі `baz` быў
выдалены і таму адсутнічае ў вывадзе.

### Натацыя ключэй

    var test = {
        'case': 'Я ключавое слова, таму я павінна быць пазначана як радок',
        delete: 'Я таксама ключавое слова, таму і я' // уздымае SyntaxError
    };

Уласцівасці аб'ектаў могуць быць пазначаныя як сімваламі, так і ў выглядзе радкоў.
Праз яшчэ адну хібу сінтаксічнага аналізатара JavaScript, вышэй прыведзены код
кіне `SyntaxError` у весіях ранейшых за ECMAScript 5.

Гэта памылка ўздымаецца праз тое, што `delete` - гэта *ключавое слова*; такім чынам,
яно мае быць пазначана як *літэрал радка* каб забяспечыць, што яно будзе какрэктна
інтэрпрэтавана старымі рухавікамі JavaScript.

[1]: http://en.wikipedia.org/wiki/Hashmap
