## Аўтаматычная ўстаўка кропкі з коскай

Хаця JavaScript мае C-падобны сінтакс, ён **не** прымушае выкарыстоўваць кропку
з коскай у кодзе, таму ёсць магчымасць прапускаць іх.

Але JavaScript — не мова без кропак з коскай. Насамрэч яны патрэбны ёй, каб разумець
зыходны код. Таму парсер JavaScript **аўтаматычна** ўстаўляе іх паўсюль, дзе
сустракае памылку адсутнасці кропкі з коскай.

    var foo = function() {
    } // памылка разбора, парсер чакаў кропку з коскай
    test()

Адбываецца ўстаўка, парсер спрабуе зноў.

    var foo = function() {
    }; // памылкі няма, парсер працягвае
    test()

Аўтаматычная ўстаўка кропкі з коскай лічыцца адной з **найвялікшых** архітэктурных
памылак у мове, бо *можа* змяніць паводзіны кода.

### Як яно працуе

Ніжэйпрыведзены код не мае кропак з коскай, таму парсер вырашае дзе іх уставіць.

    (function(window, undefined) {
        function test(options) {
            log('testing!')

            (options.list || []).forEach(function(i) {

            })

            options.value.test(
                'long string to pass here',
                'and another long string to pass'
            )

            return
            {
                foo: function() {}
            }
        }
        window.test = test

    })(window)

    (function(window) {
        window.someLibrary = {}

    })(window)

Ніжэй — вынік гульні парсера ў адгадванне.

    (function(window, undefined) {
        function test(options) {

            // Не ўстаўлена, радкі былі аб'яднаныя
            log('testing!')(options.list || []).forEach(function(i) {

            }); // <- устаўлена

            options.value.test(
                'long string to pass here',
                'and another long string to pass'
            ); // <- устаўлена

            return; // <- устаўлена, разбіў аператар return на два блока
            { // парсер лічыць гэты блок асобным
                foo: function() {}
            }; // <- устаўлена
        }
        window.test = test; // <- устаўлена

    // Радкі зноў аб'ядналіся
    })(window)(function(window) {
        window.someLibrary = {}; // <- устаўлена

    })(window); //<- устаўлена

> **Заўвага:** Парсер JavaScript не апрацоўвае "карэктна" аператар return, калі
> пасля яго пачынаецца новы радок. Магчыма прычына і не ў аўтаматычнай устаўцы
> кропак з коскай, але гэта, тым не менш, непажаданы эфект.

Парсер кардынальна памяняў паводзіны кода. У пэўных выпадках ён прымае **памылковыя
рашэнні**.

### Вядучыя дужкі

У выпадку вядучай дужкі парсер **не** уставіць кропку з коскай.

    log('testing!')
    (options.list || []).forEach(function(i) {})

Гэты код ператворыцца ў радок.

    log('testing!')(options.list || []).forEach(function(i) {})

**Вельмі** верагодна, што `log` **не** вяртае функцыю; Таму вышэйпрыведзены
код справакуе `TypeError` з заявай, што `undefined` не з'яўляецца функцыяй.

### Заключэнне

Крайне рэкамендуецца **ніколі** не прапускаць кропку з коскай. Таксама заўсёды
рэкамендуецца ставіць дужкі на той жа лініі, што і адпаведныя канструкцыі, і ніколі
не прапускаць іх у аднарадковых канструкцыях `if` / `else`. Гэтыя меры не толькі
павысяць кансістэнтнасць кода, але таксама прадухіляць ад таго, што парсер
JavaScript зменіць паводзіны кода.
