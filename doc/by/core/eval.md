## Чаму не варта выкарыстоўваць `eval`

Функцыя `eval` выконвае радок JavaScript коду ў лакальнай зоне бачнасці.

    var number = 1;
    function test() {
        var number = 2;
        eval('number = 3');
        return number;
    }
    test(); // 3
    number; // 1

Тым не менш, `eval` выконваецца ў лакальнай прасторы імён толькі ў тым выпадку, калі
яна была выклікана наўпрост *і* імя выкліканай функцыі — `eval`.

    var number = 1;
    function test() {
        var number = 2;
        var copyOfEval = eval;
        copyOfEval('number = 3');
        return number;
    }
    test(); // 2
    number; // 3

Лепш пазбягаць выкарыстоўвання `eval`. 99,9% яе «выкарыстанняў» можа быць дасягнута
**без** яе.

### Схаваны `eval`

Абедзве [функцыі тайм-аўты](#other.timeouts) `setTimeout` і `setInterval` могуць
прымаць радок у якасці першага аргумента. Гэты радок будзе **заўсёды** выконвацца
ў глабальнай прасторы імёнаў, бо `eval` не выклікаецца наўпрост у дадзеным выпадку.

### Праблемы з бяспекаю

Таксама `eval` мае праблемы з бяспекаю, бо ён выконвае **любы** перададзены код.
Таму яе **ніколі** не варта выкарыстоўваць з радкамі, што паходзяць з ненадзейных
крыніцаў.

### Заключэнне

Лепш ніколі не выкарыстоўваць `eval`. Любы код, што выкарыстоўвае яе, спрэчны ў
плане якасці, карэктнасці, прадукцыйнасці і бяспекі. Калі для таго, каб нешта
працавала, патрэбны `eval`, **не** трэба прымаць гэта рашэнне ў першую чаргу.
*Лепшым рашэннем* будзе тое, што не будзе выкарыстоўваць `eval`.
