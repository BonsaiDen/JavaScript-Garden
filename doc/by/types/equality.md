## Роўнасць і параўнанне

У JavaScript роўнасць значэнняў аб'ектаў можна вызначыць двумя спосабамі.

### Аператар роўнасці

Аператар роўнасці складаецца з двух сімвалаў 'роўна': `==`

JavaScript мае *слабую тыпізацыю*. Гэта значыць што аператар роўнасці
**прыводзіць** тыпы аб'ектаў, каб параўнаць іх.

    ""           ==   "0"           // false
    0            ==   ""            // true
    0            ==   "0"           // true
    false        ==   "false"       // false
    false        ==   "0"           // true
    false        ==   undefined     // false
    false        ==   null          // false
    null         ==   undefined     // true
    " \t\r\n"    ==   0             // true

Вышэй прыведзеная табліца паказвае вынікі прывядзення тыпаў, і гэта галоўная прычына
па якой выкаростоўванне `==` лічыцца дрэннай практыкай. Яно прыводзіць да памылак
якія цяжка адсачыць праз складаны механізм прывядзення тыпаў.

Акрамя гэтага, прывядзенне тыпаў таксама ўплывае на вытворчасць;
напрыклад, радок мае быць ператвораны ў нумар, перад тым як быць параўнаным з
іншым нумарам.

### Аператар строгай роўнасці

Аператар строгай роўнасці складаецца з **трох** сімвалаў 'роўна': `===`.

Ён дзейнічае як звычайны аператар роўнасці, за выключэннем таго, што строгая
роўнасць **не** прыводзіць аперанды да агульнага тыпу.

    ""           ===   "0"           // false
    0            ===   ""            // false
    0            ===   "0"           // false
    false        ===   "false"       // false
    false        ===   "0"           // false
    false        ===   undefined     // false
    false        ===   null          // false
    null         ===   undefined     // false
    " \t\r\n"    ===   0             // false

Вышэй прыведзеныя вынікі значна больш зразумелыя і даюць магчымасць хутчэй выявіць
памылкі ў кодзе. Гэта паляпшае код, а таксама дае прырост вытворчасці, у выпадку
калі аперанды розных тыпаў.

### Параўнанне аб'ектаў

Хоць абодва аператар `==` і `===` называюцца аператарамі **роўнасці**, яны паводзяць
сабе па рознаму калі хоць адзін аперанд тыпа `Object`.

    {} === {};                   // false
    new String('foo') === 'foo'; // false
    new Number(10) === 10;       // false
    var foo = {};
    foo === foo;                 // true

Тут абодва аператанда параўноўваюцца на **ідэнтычнасць**, а **не** на роўнасць;
то бок будзе праверана, ці з'яўляюцца яны адным **экзэмплярам** аб'екта. Гэтак жа,
як `is` у Python, або параўнанне ўказальнікаў у C.

### У заключэнне

Настойліва рэкамендуецца выкарыстоўваць толькі аператар **строгай роўнасці**.
У выпадку, калі тыпы маюць быць прыведзеныя, гэта варта рабіць [яўна](#types.casting),
а не пакідаць іх на сумленні складаных правілаў прывядзення мовы праграмавання.
