## Прывядзенне тыпаў

JavaScript - *слаба тыпізаваная* мова, таму *прывядзенне тыпаў* адбываецца
**паўсюль** дзе магчыма.

    // Гэтыя равенствы - праўдзівыя
    new Number(10) == 10; // аб'ект тыпа Number пераўтвараецца у
                          // лікавы прымітыў, праз няяўны выклік
                          // метада Number.prototype.valueOf

    10 == '10';           // Strings пераўтвараецца ў Number
    10 == '+10 ';         // Троху вар'яцтва з радкамі
    10 == '010';          // і яшчэ
    isNaN(null) == false; // null пераўтвараецца ў 0
                          // які вядома ж не NaN

    // Гэтыя равенствы - ілжывыя
    10 == 010;
    10 == '-10';

> **Заўвага для ES5:** Лічбавыя літэралы, што пачынаюцца з `0` інтэрпрэтуюцца як
> васьмірычныя (Base 8). Падтрымка васьмірычнай сістэмы была **прыбраная** у
> ECMAScript 5 strict mode.

Каб пазбегнуць вышэйпрыведзеных праблемаў, **настойліва** ракамендуецца выкарыстоўваць
[аператар строгай роўнасці](#types.equality). Зрэшты, хоць гэта і пазбаўляе ад
многіх распаўсюджаных праблемаў, існуе яшчэ шмат праблемаў, які ўзнікаюць праз
слабую тыпізацыю JavaScript.

### Канструктары ўбудаваных тыпаў

Канструктары ўбудаваных тыпаў, напрыклад, `Number` і `String` паводзяць сябе
па рознаму, у залежнасці ад таго, выклікаюцца яны з ключавым словам `new` або без яго.

    new Number(10) === 10;     // False, Object і Number
    Number(10) === 10;         // True, Number і Number
    new Number(10) + 0 === 10; // True, праз неяўнае прывядзенне

Выкарыстанне ўбудаванага тыпу, такога як `Number` у якасці канструкта створыць новы
экзэмпляр аб'екта `Number`, але пры адсутнасці ключавога слова `new` функцыя
`Number` будзе паводзіць сябе як канвертар.

У дадатак, выкарытоўванне літэралаў, або значэнняў якія не з'яўляюцца аб'ектамі
прывядзе да дадатковых прывядзенняў тыпаў.

Лепшы варыянт - гэта **яўнае** прывядзенне да аднаго з трох магчымых тыпаў.

### Прывядзенне да радка

    '' + 10 === '10'; // true

Праз даданне да значэння пустога радка, яно лёгка прыводзіцца да радка.

### Прывядзенне да лікавага тыпу

    +'10' === 10; // true

Выкарыстоўваючы **унарны** аператар плюс, магчыма пераўтварыць значэнне ў нумар.

### Прывядзенне да булевага тыпу

Выкарыстоўваючы аператар **адмаўленне (!)** двойчы, значэнне можна прыведзена
да лагічнага (булевага) тыпу.

    !!'foo';   // true
    !!'';      // false
    !!'0';     // true
    !!'1';     // true
    !!'-1'     // true
    !!{};      // true
    !!true;    // true
