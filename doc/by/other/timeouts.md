### `setTimeout` і `setInterval`

Дзякуючы асінхроннасці JavaScript магчыма запланаваць выкананне функцыі з дапамогай 
метадаў `setTimeout` і `setInterval`.

> **Заўвага:** Таймаўты **не** з'яўляюцца часткай стандарта ECMAScript. Яны былі
> распрацаваны ў [BOM, ці DOM Узровень 0][1], якія ніколі не былі аб'яўлены ці
> задакументаваны фармальна. Да гэтага часу няма рэкамендацыйных спецыфікацый,
> аднак, у дадзены момант яны стандартызаваны ў [HTML5][2]. У сувязі з гэтым 
> рэалізацыя можа адрознівацца ў залежнасці ад браўзера і рухавіка

    function foo() {}
    var id = setTimeout(foo, 1000); // вяртае Number > 0

Калі функцыя `setTimeout` выклікана, яна вяртае ID таймаўта і плануе выкананне 
`foo` **прыблізна** праз тысячу мілісекунд. 
`foo` будзе выканана **аднойчы**.

Улічваючы вырашэнні таймера рухавіка Javascript, які выконвае код,
аднапаточнасць JavaScript і тое, што іншы код, які выконваецца
можа блакаваць паток, **нельга** быць упэўненым, што вы атрымаеце затрымку,
пазначанаю ў выкліку `setTimeout`.

Функцыя, якая была перададзена як першы параметр, будзе выклікана 
*глабальным аб'ектам*, гэта азначае, што [`this`](#function.this) унутры выкліканай функцыі 
спасылаецца на глабальны аб'ект.

    function Foo() {
        this.value = 42;
        this.method = function() {
            // this спасылаецца на глабальны аб'ект
            console.log(this.value); // выведзе undefined
        };
        setTimeout(this.method, 500);
    }
    new Foo();


> **Заўвага:** Так як `setTimeout` прымае **функцыю** як першы параметр,
> распаўсюджанай з'яўляецца памылка выкарыстоўвання `setTimeout(foo(), 1000)`, у гэтым выпадку 
> будзе выкарыстоўвацца **вернутае значэнне** выкліка `foo`, а **не** `foo`. Гэта, у большасці выпадкаў, 
> маўклівая памылка, так як калі функцыя вяртае `undefined`, `setTimeout` 
> **не** выклікае памылкі.

### Паслядоўныя выклікі з дапамогай `setInterval`

У той час калі `setTimeout` выконвае функцыю толькі адзін раз, `setInterval` - як бачна з назвы - 
выконвае функцыю **кожныя** `X` milliseconds, але яе выкарыстанне не пажадана.

Код, які выконваецца, блакуе выклік з таймаўтам, у той час `setInterval` будзе 
планаваць выклікі зададзенай функцыі. Гэта можа, асабліва з маленькімі інтэрваламі,
прывесці да стварэння чаргі выклікаў функцый.

    function foo(){
        // нешта, што блакуе на 1 секунду
    }
    setInterval(foo, 100);

У прыведзеным кодзе `foo` будзе выклікана аднойчы і заблакуе выкананне на адну секунду.

У той час калі `foo` блакуе код, `setInterval` будзе планаваць наступныя яе выклікі
А калі выкананне `foo` скончана, ужо **дзесяць** наступных выклікаў будуць чакаць выканання.

### Праца з магчыма блакуючым кодам

Найбольш простае і кіруемае рашэнне гэта выкарыстоўваць `setTimeout` унутры самой функцыі.

    function foo(){
        // нешта, што блакуе на 1 секунду
        setTimeout(foo, 100);
    }
    foo();

Гэты падыход не толькі інкапсулюе выклік `setTimeout`, але таксама прадухіляе
стварэнне чаргі выклікаў і дае дадатковы кантроль. Цяпер `foo` можа сама вырашыць 
хоча яна выконвацца яшчэ раз ці не.

### Ручная чыстка таймаўтаў

Чыстка таймаўтаў і інтэрвалаў здзяйсняецца перадачай адпаведнага ID у
`clearTimeout` або `clearInterval`, гледзячы якая `set` функцыя была выкарыстана
да гэтага.

    var id = setTimeout(foo, 1000);
    clearTimeout(id);

### Чыстка ўсіх таймаўтаў

Так як няма ўбудаванага метада для выдалення ўсіх таймаўтаў і/або інтэрвалаў, 
для гэтага неабходна выкарыстоўваць брутфорс.

    // выдаліць "усе" таймаўты
    for(var i = 1; i < 1000; i++) {
        clearTimeout(i);
    }

Але могуць быць таймаўты, якія не закрануты гэтым адвольным нумарам.
Іншы шлях ажыццяўлення гэтага - прыняць, што ID таймаўта павялічваецца на
адзін пасля кожнага выкліку `setTimeout`.

    // выдаліць "усе" таймаўты
    var biggestTimeoutId = window.setTimeout(function(){}, 1),
    i;
    for(i = 1; i <= biggestTimeoutId; i++) {
        clearTimeout(i);
    }

Не гледзячы на тое, што зараз гэта працуе на ўсіх асноўных браўзерах, тое, што ID
павінны быць арганізаваны такім шляхам не пазначана ў спецыфікацыі і можа змяніцца. Таму 
замест гэтага рэкамендуецца сачыць за ўсімі ID таймаўтаў, каб яны маглі быць выдалены паасобку.

### Схаванае выкарыстанне `eval`

`setTimeout` і `setInterval` таксама могуць прымаць радок у якасці першага параметра.
Гэту магчымасць **ніколі** не трэба выкарыстоўваць, бо ўнутрана вызываецца `eval`.

> **Заўвага:** Дакладны механізм работы пры перадачы радка можа адрозніваецца ў
> розных JavaScript рэалізацыях. Напрыклад, JScript ад Microsoft выкарыстоўвае
> канструктар `Function` замест `eval`.

    function foo() {
        // будзе выклікана
    }

    function bar() {
        function foo() {
            // ніколі не будзе выклікана
        }
        setTimeout('foo()', 1000);
    }
    bar();

Паколькі `eval` не выклікана [напрамую](#core.eval), радок, які перададзены 
`setTimeout` будзе выкананы ў *глабальным скоўпе*; такім чынам, не будзе выкарыстана 
лакальная пераменная `foo` са скоўпа `bar`.

Адсюль вынікае рэкамендацыя **не** выкарыстоўваць радок для перадачы аргументаў у
функцыю, якая будзе вызывацца адной з таймаўт функцый. 

    function foo(a, b, c) {}
    
    // НІКОЛІ так не рабіце
    setTimeout('foo(1, 2, 3)', 1000)

    // Замест выкарыстоўвайце ананімныя функцыі
    setTimeout(function() {
        foo(1, 2, 3);
    }, 1000)

> **Заўвага:** Нягледзячы на тое, што сінтаксіс `setTimeout(foo, 1000, 1, 2, 3)` можна выкарыстоўваць,
> гэта не рэкамендуецца, так як можа прывесці да 
> непрыкметных памылак пры выкарыстанні з [метадамі](#function.this).
> Больш таго, сінтаксіс можа не працаваць у некаторых рэалізацыях JavaScript.
> Напрыклад, Internet Explorer ад Microsoft  [**не** перадае аргументы напрамую зваротнаму выкліку](3).

### У заключэнне

Радок **ніколі** не павінен быць выкарыстаны як параметр `setTimeout` ці 
`setInterval`. Відавочны знак **сапраўды** благога кода гэта калі функцыя, якая будзе выклікана, 
патрабуе аргументы. Трэба перадаваць *ананімную функцыю*, якая будзе адказваць за
выклік патрэбнай функцыі.

Больш таго, трэба пазбягаць выкарыстання `setInterval`, таму што яе планавальнік не блакуецца 
выкананнем JavaScript.

[1]: http://www.nczonline.net/blog/2009/09/29/web-definitions-dom-ajax-and-more/ "Web definitions: DOM, Ajax, and more"
[2]: http://www.w3.org/TR/2014/WD-html5-20140617/webappapis.html#timers "6 Web application APIs - HTML5"
[3]: http://msdn.microsoft.com/en-us/library/ie/ms536753(v=vs.85).aspx "setTimeout method (Internet Explorer)"
