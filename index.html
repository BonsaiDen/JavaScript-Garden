<!DOCTYPE html><html lang="en"><head><title>JavaScript Garden</title><meta charset="utf-8"><meta name="description" content="A Guide to JavaScript's Quirks and Flaws."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/JavaScript-Garden/favicon.ico?v=2"><link rel="stylesheet" href="style/garden.css" media="all"><link rel="stylesheet" href="style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]--></head><body><!-- Navigation--><nav id="nav_main"><div><ul> <li class="active"><a href="/JavaScript-Garden/" title="JavaScript Garden">en</a></li><li><a href="/JavaScript-Garden/es" title="Jardín de JavaScript">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha">fi</a></li><li><a href="/JavaScript-Garden/hu" title="JavaScript Garden">hu</a></li><li><a href="/JavaScript-Garden/it" title="JavaScript Garden">it</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden">pl</a></li><li><a href="/JavaScript-Garden/ru" title="JavaScript Гарден">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript 秘密花园">zh</a></li><li><a href="/JavaScript-Garden/zhtw" title="JavaScript 庭院">zhtw</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Intro</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">Objects</a></h1><ul><li><a href="#object.general">Object Usage and Properties</a></li><li><a href="#object.prototype">The Prototype</a></li><li><a href="#object.hasownproperty"><code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">The <code>for in</code> Loop</a></li></ul></li><li class="nav_function"><h1><a href="#function">Functions</a></h1><ul><li><a href="#function.general">Function Declarations and Expressions</a></li><li><a href="#function.this">How <code>this</code> Works</a></li><li><a href="#function.closures">Closures and References</a></li><li><a href="#function.arguments">The <code>arguments</code> Object</a></li><li><a href="#function.constructors">Constructors</a></li><li><a href="#function.scopes">Scopes and Namespaces</a></li></ul></li><li class="nav_array"><h1><a href="#array">Arrays</a></h1><ul><li><a href="#array.general">Array Iteration and Properties</a></li><li><a href="#array.constructor">The <code>Array</code> Constructor</a></li></ul></li><li class="nav_types"><h1><a href="#types">Types</a></h1><ul><li><a href="#types.equality">Equality and Comparisons</a></li><li><a href="#types.typeof">The <code>typeof</code> Operator</a></li><li><a href="#types.instanceof">The <code>instanceof</code> Operator</a></li><li><a href="#types.casting">Type Casting</a></li></ul></li><li class="nav_core"><h1><a href="#core">Core</a></h1><ul><li><a href="#core.eval">Why Not to Use <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> and <code>null</code></a></li><li><a href="#core.semicolon">Automatic Semicolon Insertion</a></li><li><a href="#core.delete">The <code>delete</code> Operator</a></li></ul></li><li class="nav_other"><h1><a href="#other">Other</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> and <code>setInterval</code></a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Intro</h1></header><!-- Articles--><article id="intro.index"><h2>Intro</h2><div><p><strong>JavaScript Garden</strong> is a growing collection of documentation about the most 
quirky parts of the JavaScript programming language. It gives advice to 
avoid common mistakes and subtle bugs, as well as performance issues and bad 
practices, that non-expert JavaScript programmers may encounter on their 
endeavours into the depths of the language.</p>
<p>JavaScript Garden does <strong>not</strong> aim to teach you JavaScript. Former knowledge
of the language is strongly recommended in order to understand the topics covered
in this guide. In order to learn the basics of the language, please head over to 
the excellent <a href="https://developer.mozilla.org/en/JavaScript/Guide">guide</a> on the Mozilla Developer Network.</p>
<h2>The Authors</h2>
<p>This guide is the work of two lovely <a href="http://stackoverflow.com/">Stack Overflow</a> users, <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Ivo Wetzel</a>
(Writing) and <a href="http://stackoverflow.com/users/313758/yi-jiang">Zhang Yi Jiang</a> (Design).</p>
<p>It&#39;s currently maintained by <a href="http://truffles.me.uk">Tim Ruffles</a>.</p>
<h2>Contributors</h2>
<ul>
<li>Too many to list here, <a href="https://github.com/BonsaiDen/JavaScript-Garden/graphs/contributors">see all contributors</a>.</li>
</ul>
<h2>Hosting</h2>
<p>JavaScript Garden is hosted on GitHub, but <a href="http://cramerdev.com/">Cramer Development</a> supports us
with a mirror at <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p>
<h2>License</h2>
<p>JavaScript Garden is published under the <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">MIT license</a> and hosted on
<a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. If you find errors or typos please <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">file an issue</a> or a pull 
request on the repository. You can also find us in the <a href="http://chat.stackoverflow.com/rooms/17/javascript">JavaScript room</a> on
Stack Overflow chat.</p>
</div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Objects</h1></header><!-- Articles--><article id="object.general"><h2>Object Usage and Properties</h2><div><p>Everything in JavaScript acts like an object, with the only two exceptions being 
<a href="#core.undefined"><code>null</code></a> and <a href="#core.undefined"><code>undefined</code></a>.</p>
<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1</code></pre>
<p>A common misconception is that number literals cannot be used as
objects. That is because a flaw in JavaScript&#39;s parser tries to parse the <em>dot 
notation</em> on a number as a floating point literal.</p>
<pre><code>2.toString(); // raises SyntaxError</code></pre>
<p>There are a couple of workarounds that can be used to make number literals act
as objects too.</p>
<pre><code>2..toString(); // the second point is correctly recognized
2 .toString(); // note the space left to the dot
(2).toString(); // 2 is evaluated first</code></pre>
</div><div><h3>Objects as a Data Type</h3>
<p>Objects in JavaScript can also be used as <a href="http://en.wikipedia.org/wiki/Hashmap"><em>Hashmaps</em></a>; they mainly consist 
of named properties mapping to values.</p>
<p>Using an object literal - <code>{}</code> notation - it is possible to create a 
plain object. This new object <a href="#object.prototype">inherits</a> from <code>Object.prototype</code> and 
does not have <a href="#object.hasownproperty">own properties</a> defined.</p>
<pre><code>var foo = {}; // a new empty object

// a new object with a &#39;test&#39; property with value 12
var bar = {test: 12}; </code></pre>
</div><div><h3>Accessing Properties</h3>
<p>The properties of an object can be accessed in two ways, via either the dot
notation or the square bracket notation.</p>
<pre><code>var foo = {name: &#39;kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // works</code></pre>
<p>The notations work almost identically, with the only difference being that the
square bracket notation allows for dynamic setting of properties and
the use of property names that would otherwise lead to a syntax error.</p>
</div><div><h3>Deleting Properties</h3>
<p>The only way to remove a property from an object is to use the <code>delete</code>
operator; setting the property to <code>undefined</code> or <code>null</code> only removes the
<em>value</em> associated with the property, but not the <em>key</em>.</p>
<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}</code></pre>
<p>The above outputs both <code>bar undefined</code> and <code>foo null</code> - only <code>baz</code> was
removed and is therefore missing from the output.</p>
</div><div><h3>Notation of Keys</h3>
<pre><code>var test = {
    &#39;case&#39;: &#39;I am a keyword, so I must be notated as a string&#39;,
    delete: &#39;I am a keyword, so me too&#39; // raises SyntaxError
};</code></pre>
<p>Object properties can be both notated as plain characters and as strings. Due to
another mis-design in JavaScript&#39;s parser, the above will throw 
a <code>SyntaxError</code> prior to ECMAScript 5.</p>
<p>This error arises from the fact that <code>delete</code> is a <em>keyword</em>; therefore, it must be 
notated as a <em>string literal</em> to ensure that it will be correctly interpreted by
older JavaScript engines.</p>
</div></article><article id="object.prototype"><h2>The Prototype</h2><div><p>JavaScript does not feature a classical inheritance model; instead, it uses a
<em>prototypal</em> one.</p>
<p>While this is often considered to be one of JavaScript&#39;s weaknesses, the
prototypal inheritance model is in fact more powerful than the classic model.
It is, for example, fairly trivial to build a classic model on top of a
prototypal model, while the other way around is a far more difficult task.</p>
<p>JavaScript is the only widely used language that features prototypal
inheritance, so it can take time to adjust to the differences between the two
models.</p>
<p>The first major difference is that inheritance in JavaScript uses <em>prototype
chains</em>.</p>
<aside>
<p><strong>Note:</strong> Simply using <code>Bar.prototype = Foo.prototype</code> will result in both objects
sharing the <strong>same</strong> prototype. Therefore, changes to either object&#39;s prototype
will affect the prototype of the other as well, which in most cases is not the
desired effect.</p>
</aside>
<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype = {
    method: function() {}
};

function Bar() {}

// Set Bar&#39;s prototype to a new instance of Foo
Bar.prototype = new Foo();
Bar.prototype.foo = &#39;Hello World&#39;;

// Make sure to list Bar as the actual constructor
Bar.prototype.constructor = Bar;

var test = new Bar(); // create a new bar instance

// The resulting prototype chain
test [instance of Bar]
    Bar.prototype [instance of Foo]
        { foo: &#39;Hello World&#39; }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* etc. */ }</code></pre>
<p>In the code above, the object <code>test</code> will inherit from both <code>Bar.prototype</code> and
<code>Foo.prototype</code>; hence, it will have access to the function <code>method</code> that was
defined on <code>Foo</code>. It will also have access to the property <code>value</code> of the
<strong>one</strong> <code>Foo</code> instance that is its prototype. It is important to note that <code>new
Bar()</code> does <strong>not</strong> create a new <code>Foo</code> instance, but reuses the one assigned to
its prototype; thus, all <code>Bar</code> instances will share the <strong>same</strong> <code>value</code> property.</p>
<aside>
<p><strong>Note:</strong> Do <strong>not</strong> use <code>Bar.prototype = Foo</code>, since it will not point to
the prototype of <code>Foo</code> but rather to the function object <code>Foo</code>. So the
prototype chain will go over <code>Function.prototype</code> and not <code>Foo.prototype</code>;
therefore, <code>method</code> will not be on the prototype chain.</p>
</aside>
</div><div><h3>Property Lookup</h3>
<p>When accessing the properties of an object, JavaScript will traverse the
prototype chain <strong>upwards</strong> until it finds a property with the requested name.</p>
<p>If it reaches the top of the chain - namely <code>Object.prototype</code> - and still
hasn&#39;t found the specified property, it will return the value
<a href="#core.undefined">undefined</a> instead.</p>
</div><div><h3>The Prototype Property</h3>
<p>While the prototype property is used by the language to build the prototype
chains, it is still possible to assign <strong>any</strong> given value to it. However,
primitives will simply get ignored when assigned as a prototype.</p>
<pre><code>function Foo() {}
Foo.prototype = 1; // no effect</code></pre>
<p>Assigning objects, as shown in the example above, will work, and allows for dynamic
creation of prototype chains.</p>
</div><div><h3>Performance</h3>
<p>The lookup time for properties that are high up on the prototype chain can have
a negative impact on performance, and this may be significant in code where
performance is critical. Additionally, trying to access non-existent properties
will always traverse the full prototype chain.</p>
<p>Also, when <a href="#object.forinloop">iterating</a> over the properties of an object
<strong>every</strong> property that is on the prototype chain will be enumerated.</p>
</div><div><h3>Extension of Native Prototypes</h3>
<p>One mis-feature that is often used is to extend <code>Object.prototype</code> or one of the
other built in prototypes.</p>
<p>This technique is called <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a> and breaks <em>encapsulation</em>. While
used by popular frameworks such as <a href="http://prototypejs.org/">Prototype</a>, there is still no good
reason for cluttering built-in types with additional <em>non-standard</em> functionality.</p>
<p>The <strong>only</strong> good reason for extending a built-in prototype is to backport
the features of newer JavaScript engines; for example,
<a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>.</p>
</div><div><h3>In Conclusion</h3>
<p>It is <strong>essential</strong> to understand the prototypal inheritance model before
writing complex code that makes use of it. Also, be aware of the length of the
prototype chains in your code and break them up if necessary to avoid possible
performance problems. Further, the native prototypes should <strong>never</strong> be
extended unless it is for the sake of compatibility with newer JavaScript
features.</p>
</div></article><article id="object.hasownproperty"><h2><code>hasOwnProperty</code></h2><div><p>To check whether an object has a property defined on <em>itself</em> and not somewhere
on its <a href="#object.prototype">prototype chain</a>, it is necessary to use the
<code>hasOwnProperty</code> method which all objects inherit from <code>Object.prototype</code>.</p>
<aside>
<p><strong>Note:</strong> It is <strong>not</strong> enough to check whether a property is <code>undefined</code>. The
property might very well exist, but its value just happens to be set to
<code>undefined</code>.</p>
</aside>
<p><code>hasOwnProperty</code> is the only thing in JavaScript which deals with properties and
does <strong>not</strong> traverse the prototype chain.</p>
<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1;
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true</code></pre>
<p>Only <code>hasOwnProperty</code> will give the correct and expected result; this is
essential when iterating over the properties of any object. There is <strong>no</strong> other
way to exclude properties that are not defined on the object itself, but
somewhere on its prototype chain.</p>
</div><div><h3><code>hasOwnProperty</code> as a Property</h3>
<p>JavaScript does not protect the property name <code>hasOwnProperty</code>; thus, if the
possibility exists that an object might have a property with this name, it is
necessary to use an <em>external</em> <code>hasOwnProperty</code> to get correct results.</p>
<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Here be dragons&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // always returns false

// Use another Object&#39;s hasOwnProperty and call it with &#39;this&#39; set to foo
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// It&#39;s also possible to use hasOwnProperty from the Object
// prototype for this purpose
Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // true</code></pre>
</div><div><h3>In Conclusion</h3>
<p>Using <code>hasOwnProperty</code> is the <strong>only</strong> reliable method to check for the
existence of a property on an object. It is recommended that <code>hasOwnProperty</code>
is used in <strong>every</strong> <a href="#object.forinloop"><code>for in</code> loop</a> to avoid errors from
extended native <a href="#object.prototype">prototypes</a>.</p>
</div></article><article id="object.forinloop"><h2>The <code>for in</code> Loop</h2><div><p>Just like the <code>in</code> operator, the <code>for in</code> loop traverses the prototype
chain when iterating over the properties of an object.</p>
<aside>
<p><strong>Note:</strong> The <code>for in</code> loop will <strong>not</strong> iterate over any properties that 
have their <code>enumerable</code> attribute set to <code>false</code>; for example, the <code>length</code> 
property of an array.</p>
</aside>
<pre><code>// Poisoning Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // prints both bar and moo
}</code></pre>
<p>Since it is not possible to change the behavior of the <code>for in</code> loop itself, it
is necessary to filter out the unwanted properties inside the loop body; 
this is done using the <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> method of 
<code>Object.prototype</code>.</p>
<aside>
<p><strong>Note:</strong> Since <code>for in</code> always traverses the complete prototype chain, it
will get slower with each additional layer of inheritance added to an object.</p>
</aside>
</div><div><h3>Using <code>hasOwnProperty</code> for Filtering</h3>
<pre><code>// still the foo from above
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}</code></pre>
<p>This version is the only correct one to use. Due to the use of <code>hasOwnProperty</code>, it
will <strong>only</strong> print out <code>moo</code>. When <code>hasOwnProperty</code> is left out, the code is 
prone to errors in cases where the native prototypes - e.g. <code>Object.prototype</code> - 
have been extended.</p>
<p>One widely used framework that extends <code>Object.prototype</code> is <a href="http://www.prototypejs.org/">Prototype</a>.
When this framework is included, <code>for in</code> loops that do not use
<code>hasOwnProperty</code> are guaranteed to break.</p>
</div><div><h3>In Conclusion</h3>
<p>It is recommended to <strong>always</strong> use <code>hasOwnProperty</code>. Assumptions should never
be made about the environment the code is running in, or whether the native
prototypes have been extended or not.</p>
</div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Functions</h1></header><!-- Articles--><article id="function.general"><h2>Function Declarations and Expressions</h2><div><p>Functions in JavaScript are first class objects. That means they can be 
passed around like any other value. One common use of this feature is to pass
an <em>anonymous function</em> as a callback to another, possibly an asynchronous function.</p>
</div><div><h3>The <code>function</code> Declaration</h3>
<pre><code>function foo() {}</code></pre>
<p>The above function gets <a href="#function.scopes">hoisted</a> before the execution of the
program starts; thus, it is available <em>everywhere</em> in the scope it was
<em>defined</em>, even if called before the actual definition in the source.</p>
<pre><code>foo(); // Works because foo was created before this code runs
function foo() {}</code></pre>
</div><div><h3>The <code>function</code> Expression</h3>
<pre><code>var foo = function() {};</code></pre>
<p>This example assigns the unnamed and <em>anonymous</em> function to the variable <code>foo</code>. </p>
<pre><code>foo; // &#39;undefined&#39;
foo(); // this raises a TypeError
var foo = function() {};</code></pre>
<p>Due to the fact that <code>var</code> is a declaration that hoists the variable name <code>foo</code> 
before the actual execution of the code starts, <code>foo</code> is already declared when 
the script gets executed.</p>
<p>But since assignments only happen at runtime, the value of <code>foo</code> will default
to <a href="#core.undefined">undefined</a> before the corresponding code is executed.</p>
</div><div><h3>Named Function Expression</h3>
<p>Another special case is the assignment of named functions.</p>
<pre><code>var foo = function bar() {
    bar(); // Works
}
bar(); // ReferenceError</code></pre>
<p>Here, <code>bar</code> is not available in the outer scope, since the function only gets
assigned to <code>foo</code>; however, inside of <code>bar</code>, it is available. This is due to 
how <a href="#function.scopes">name resolution</a> in JavaScript works, the name of the 
function is <em>always</em> made available in the local scope of the function itself.</p>
</div></article><article id="function.this"><h2>How <code>this</code> Works</h2><div><p>JavaScript has a different concept of what the special name <code>this</code> refers to 
than most other programming languages. There are exactly <strong>five</strong> different 
ways in which the value of <code>this</code> can be bound in the language.</p>
</div><div><h3>The Global Scope</h3>
<pre><code>this;</code></pre>
<p>When using <code>this</code> in global scope, it will simply refer to the <em>global</em> object.</p>
</div><div><h3>Calling a Function</h3>
<pre><code>foo();</code></pre>
<p>Here, <code>this</code> will again refer to the <em>global</em> object.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> In strict mode, the global case <strong>no longer</strong> exists.
<code>this</code> will instead have the value of <code>undefined</code> in that case.</p>
</aside>
</div><div><h3>Calling a Method</h3>
<pre><code>test.foo(); </code></pre>
<p>In this example, <code>this</code> will refer to <code>test</code>.</p>
</div><div><h3>Calling a Constructor</h3>
<pre><code>new foo(); </code></pre>
<p>A function call that is preceded by the <code>new</code> keyword acts as
a <a href="#function.constructors">constructor</a>. Inside the function, <code>this</code> will refer 
to a <em>newly created</em> <code>Object</code>.</p>
</div><div><h3>Explicit Setting of <code>this</code></h3>
<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // array will expand to the below
foo.call(bar, 1, 2, 3); // results in a = 1, b = 2, c = 3</code></pre>
<p>When using the <code>call</code> or <code>apply</code> methods of <code>Function.prototype</code>, the value of
<code>this</code> inside the called function gets <strong>explicitly set</strong> to the first argument 
of the corresponding function call.</p>
<p>As a result, in the above example the <em>method case</em> does <strong>not</strong> apply, and <code>this</code> 
inside of <code>foo</code> will be set to <code>bar</code>.</p>
<aside>
<p><strong>Note:</strong> <code>this</code> <strong>cannot</strong> be used to refer to the object inside of an <code>Object</code>
literal. So <code>var obj = {me: this}</code> will <strong>not</strong> result in <code>me</code> referring to
<code>obj</code>, since <code>this</code> only gets bound by one of the five listed cases.</p>
</aside>
</div><div><h3>Common Pitfalls</h3>
<p>While most of these cases make sense, the first can be considered another
mis-design of the language because it <strong>never</strong> has any practical use.</p>
<pre><code>Foo.method = function() {
    function test() {
        // this is set to the global object
    }
    test();
}</code></pre>
<p>A common misconception is that <code>this</code> inside of <code>test</code> refers to <code>Foo</code>; while in
fact, it <strong>does not</strong>.</p>
<p>In order to gain access to <code>Foo</code> from within <code>test</code>, it is necessary to create a 
local variable inside of <code>method</code> that refers to <code>Foo</code>.</p>
<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Use that instead of this here
    }
    test();
}</code></pre>
<p><code>that</code> is just a normal variable name, but it is commonly used for the reference to an 
outer <code>this</code>. In combination with <a href="#function.closures">closures</a>, it can also 
be used to pass <code>this</code> values around.</p>
</div><div><h3>Assigning Methods</h3>
<p>Another thing that does <strong>not</strong> work in JavaScript is function aliasing, which is
<strong>assigning</strong> a method to a variable.</p>
<pre><code>var test = someObject.methodTest;
test();</code></pre>
<p>Due to the first case, <code>test</code> now acts like a plain function call; therefore,
<code>this</code> inside it will no longer refer to <code>someObject</code>.</p>
<p>While the late binding of <code>this</code> might seem like a bad idea at first, in 
fact, it is what makes <a href="#object.prototype">prototypal inheritance</a> work. </p>
<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();</code></pre>
<p>When <code>method</code> gets called on an instance of <code>Bar</code>, <code>this</code> will now refer to that
very instance. </p>
</div></article><article id="function.closures"><h2>Closures and References</h2><div><p>One of JavaScript&#39;s most powerful features is the availability of <em>closures</em>.
With closures, scopes <strong>always</strong> keep access to the outer scope, in which they
were defined. Since the only scoping that JavaScript has is 
<a href="#function.scopes">function scope</a>, all functions, by default, act as closures.</p>
</div><div><h3>Emulating private variables</h3>
<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5</code></pre>
<p>Here, <code>Counter</code> returns <strong>two</strong> closures: the function <code>increment</code> as well as 
the function <code>get</code>. Both of these functions keep a <strong>reference</strong> to the scope of 
<code>Counter</code> and, therefore, always keep access to the <code>count</code> variable that was 
defined in that scope.</p>
</div><div><h3>Why Private Variables Work</h3>
<p>Since it is not possible to reference or assign scopes in JavaScript, there is 
<strong>no</strong> way of accessing the variable <code>count</code> from the outside. The only way to 
interact with it is via the two closures.</p>
<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};</code></pre>
<p>The above code will <strong>not</strong> change the variable <code>count</code> in the scope of <code>Counter</code>, 
since <code>foo.hack</code> was not defined in <strong>that</strong> scope. It will instead create - or 
override - the <em>global</em> variable <code>count</code>.</p>
</div><div><h3>Closures Inside Loops</h3>
<p>One often made mistake is to use closures inside of loops, as if they were
copying the value of the loop&#39;s index variable.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);  
    }, 1000);
}</code></pre>
<p>The above will <strong>not</strong> output the numbers <code>0</code> through <code>9</code>, but will simply print
the number <code>10</code> ten times.</p>
<p>The <em>anonymous</em> function keeps a <strong>reference</strong> to <code>i</code>. At the time 
<code>console.log</code> gets called, the <code>for loop</code> has already finished, and the value of 
<code>i</code> has been set to <code>10</code>.</p>
<p>In order to get the desired behavior, it is necessary to create a <strong>copy</strong> of 
the value of <code>i</code>.</p>
</div><div><h3>Avoiding the Reference Problem</h3>
<p>In order to copy the value of the loop&#39;s index variable, it is best to use an 
<a href="#function.scopes">anonymous wrapper</a>.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);  
        }, 1000);
    })(i);
}</code></pre>
<p>The anonymous outer function gets called immediately with <code>i</code> as its first 
argument and will receive a copy of the <strong>value</strong> of <code>i</code> as its parameter <code>e</code>.</p>
<p>The anonymous function that gets passed to <code>setTimeout</code> now has a reference to 
<code>e</code>, whose value does <strong>not</strong> get changed by the loop.</p>
<p>There is another possible way of achieving this, which is to return a function 
from the anonymous wrapper that will then have the same behavior as the code 
above.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}</code></pre>
<p>There&#39;s yet another way to accomplish this by using <code>.bind</code>, which can bind
a <code>this</code> context and arguments to function. It behaves identially to the code
above</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(console.log.bind(console, i), 1000);
}</code></pre>
</div></article><article id="function.arguments"><h2>The <code>arguments</code> Object</h2><div><p>Every function scope in JavaScript can access the special variable <code>arguments</code>.
This variable holds a list of all the arguments that were passed to the function.</p>
<aside>
<p><strong>Note:</strong> In case <code>arguments</code> has already been defined inside the function&#39;s
scope either via a <code>var</code> statement or being the name of a formal parameter,
the <code>arguments</code> object will not be created.</p>
</aside>
<p>The <code>arguments</code> object is <strong>not</strong> an <code>Array</code>. While it has some of the 
semantics of an array - namely the <code>length</code> property - it does not inherit from 
<code>Array.prototype</code> and is in fact an <code>Object</code>.</p>
<p>Due to this, it is <strong>not</strong> possible to use standard array methods like <code>push</code>,
<code>pop</code> or <code>slice</code> on <code>arguments</code>. While iteration with a plain <code>for</code> loop works 
just fine, it is necessary to convert it to a real <code>Array</code> in order to use the 
standard <code>Array</code> methods on it.</p>
</div><div><h3>Converting to an Array</h3>
<p>The code below will return a new <code>Array</code> containing all the elements of the 
<code>arguments</code> object.</p>
<pre><code>Array.prototype.slice.call(arguments);</code></pre>
<p>Because this conversion is <strong>slow</strong>, it is <strong>not recommended</strong> to use it in
performance-critical sections of code.</p>
</div><div><h3>Passing Arguments</h3>
<p>The following is the recommended way of passing arguments from one function to
another.</p>
<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // do stuff here
}</code></pre>
<p>Another trick is to use both <code>call</code> and <code>apply</code> together to create fast, unbound
wrappers.</p>
<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Create an unbound version of &quot;method&quot; 
// It takes the parameters: this, arg1, arg2...argN
Foo.method = function() {

    // Result: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);
};</code></pre>
</div><div><h3>Formal Parameters and Arguments Indices</h3>
<p>The <code>arguments</code> object creates <em>getter</em> and <em>setter</em> functions for both its 
properties, as well as the function&#39;s formal parameters.</p>
<p>As a result, changing the value of a formal parameter will also change the value
of the corresponding property on the <code>arguments</code> object, and the other way around.</p>
<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);</code></pre>
</div><div><h3>Performance Myths and Truths</h3>
<p>The only time  the <code>arguments</code> object is not created is where it is declared as
a name inside of a function or one of its formal parameters. It does not matter
whether it is used or not.</p>
<p>Both <em>getters</em> and <em>setters</em> are <strong>always</strong> created; thus, using it has nearly 
no performance impact at all, especially not in real world code where there is 
more than a simple access to the <code>arguments</code> object&#39;s properties.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> These <em>getters</em> and <em>setters</em> are not created in strict mode.</p>
</aside>
<p>However, there is one case which will drastically reduce the performance in
modern JavaScript engines. That case is the use of <code>arguments.callee</code>.</p>
<pre><code>function foo() {
    arguments.callee; // do something with this function object
    arguments.callee.caller; // and the calling function object
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // Would normally be inlined...
    }
}</code></pre>
<p>In the above code, <code>foo</code> can no longer be a subject to <a href="http://en.wikipedia.org/wiki/Inlining">inlining</a> since it 
needs to know about both itself and its caller. This not only defeats possible 
performance gains that would arise from inlining, but it also breaks encapsulation
because the function may now be dependent on a specific calling context.</p>
<p>Making use of <code>arguments.callee</code> or any of its properties is <strong>highly discouraged</strong>.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> In strict mode, <code>arguments.callee</code> will throw a <code>TypeError</code> since 
its use has been deprecated.</p>
</aside>
</div></article><article id="function.constructors"><h2>Constructors</h2><div><p>Constructors in JavaScript are yet again different from many other languages. Any
function call that is preceded by the <code>new</code> keyword acts as a constructor.</p>
<p>Inside the constructor - the called function - the value of <code>this</code> refers to a 
newly created object. The <a href="#object.prototype">prototype</a> of this <strong>new</strong> 
object is set to the <code>prototype</code> of the function object that was invoked as the
constructor.</p>
<p>If the function that was called has no explicit <code>return</code> statement, then it
implicitly returns the value of <code>this</code> - the new object. </p>
<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();</code></pre>
<p>The above calls <code>Foo</code> as constructor and sets the <code>prototype</code> of the newly
created object to <code>Foo.prototype</code>.</p>
<p>In case of an explicit <code>return</code> statement, the function returns the value 
specified by that statement, but <strong>only</strong> if the return value is an <code>Object</code>.</p>
<pre><code>function Bar() {
    return 2;
}
new Bar(); // a new object

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // the returned object</code></pre>
<p>When the <code>new</code> keyword is omitted, the function will <strong>not</strong> return a new object. </p>
<pre><code>function Foo() {
    this.bla = 1; // gets set on the global object
}
Foo(); // undefined</code></pre>
<p>While the above example might still appear to work in some cases, due to the 
workings of <a href="#function.this"><code>this</code></a> in JavaScript, it will use the 
<em>global object</em> as the value of <code>this</code>.</p>
</div><div><h3>Factories</h3>
<p>In order to be able to omit the <code>new</code> keyword, the constructor function has to 
explicitly return a value.</p>
<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();</code></pre>
<p>Both calls to <code>Bar</code> return the same thing, a newly create object that
has a property called <code>method</code>, which is a 
<a href="#function.closures">Closure</a>.</p>
<p>It should also be noted that the call <code>new Bar()</code> does <strong>not</strong> affect the
prototype of the returned object. While the prototype will be set on the newly
created object, <code>Bar</code> never returns that new object.</p>
<p>In the above example, there is no functional difference between using and
not using the <code>new</code> keyword.</p>
</div><div><h3>Creating New Objects via Factories</h3>
<p>It is often recommended to <strong>not</strong> use <code>new</code> because forgetting its use may
lead to bugs.</p>
<p>In order to create a new object, one should rather use a factory and construct a 
new object inside of that factory.</p>
<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}</code></pre>
<p>While the above is robust against a missing <code>new</code> keyword and certainly makes 
the use of <a href="#function.closures">private variables</a> easier, it comes with some 
downsides.</p>
<ol>
<li>It uses more memory since the created objects do <strong>not</strong> share the methods
on a prototype.</li>
<li>In order to inherit, the factory needs to copy all the methods from another
object or put that object on the prototype of the new object.</li>
<li>Dropping the prototype chain just because of a left out <code>new</code> keyword
is contrary to the spirit of the language.</li>
</ol>
</div><div><h3>In Conclusion</h3>
<p>While omitting the <code>new</code> keyword might lead to bugs, it is certainly <strong>not</strong> a
reason to drop the use of prototypes altogether. In the end it comes down to
which solution is better suited for the needs of the application. It is
especially important to choose a specific style of object creation and use it
<strong>consistently</strong>.</p>
</div></article><article id="function.scopes"><h2>Scopes and Namespaces</h2><div><p>Although JavaScript deals fine with the syntax of two matching curly
braces for blocks, it does <strong>not</strong> support block scope; hence, all that is left 
in the language is <em>function scope</em>.</p>
<pre><code>function test() { // a scope
    for(var i = 0; i &lt; 10; i++) { // not a scope
        // count
    }
    console.log(i); // 10
}</code></pre>
<aside>
<p><strong>Note:</strong> When not used in an assignment, return statement or as a function 
argument, the <code>{...}</code> notation will get interpreted as a block statement and 
<strong>not</strong> as an object literal. This, in conjunction with 
<a href="#core.semicolon">automatic insertion of semicolons</a>, can lead to subtle errors.</p>
</aside>
<p>There are also no distinct namespaces in JavaScript, which means that everything 
gets defined in one <em>globally shared</em> namespace.</p>
<p>Each time a variable is referenced, JavaScript will traverse upwards through all 
the scopes until it finds it. In the case that it reaches the global scope and 
still has not found the requested name, it will raise a <code>ReferenceError</code>.</p>
</div><div><h3>The Bane of Global Variables</h3>
<pre><code>// script A
foo = &#39;42&#39;;

// script B
var foo = &#39;42&#39;</code></pre>
<p>The above two scripts do <strong>not</strong> have the same effect. Script A defines a 
variable called <code>foo</code> in the <em>global</em> scope, and script B defines a <code>foo</code> in the
<em>current</em> scope.</p>
<p>Again, that is <strong>not</strong> at all the <em>same effect</em>: not using <code>var</code> can have major 
implications.</p>
<pre><code>// global scope
var foo = 42;
function test() {
    // local scope
    foo = 21;
}
test();
foo; // 21</code></pre>
<p>Leaving out the <code>var</code> statement inside the function <code>test</code> will override the 
value of <code>foo</code>. While this might not seem like a big deal at first, having 
thousands of lines of JavaScript and not using <code>var</code> will introduce horrible,
hard-to-track-down bugs.</p>
<pre><code>// global scope
var items = [/* some list */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // scope of subLoop
    for(i = 0; i &lt; 10; i++) { // missing var statement
        // do amazing stuff!
    }
}</code></pre>
<p>The outer loop will terminate after the first call to <code>subLoop</code>,  since <code>subLoop</code>
overwrites the global value of <code>i</code>. Using a <code>var</code> for the second <code>for</code> loop would
have easily avoided this error. The <code>var</code> statement should <strong>never</strong> be left out 
unless the <em>desired effect</em> is to affect the outer scope.</p>
</div><div><h3>Local Variables</h3>
<p>The only source for local variables in JavaScript are
<a href="#function.general">function</a> parameters and variables declared via the 
<code>var</code> statement.</p>
<pre><code>// global scope
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // local scope of the function test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);</code></pre>
<p>While <code>foo</code> and <code>i</code> are local variables inside the scope of the function <code>test</code>,
the assignment of <code>bar</code> will override the global variable with the same name.</p>
</div><div><h3>Hoisting</h3>
<p>JavaScript <strong>hoists</strong> declarations. This means that both <code>var</code> statements and
<code>function</code> declarations will be moved to the top of their enclosing scope.</p>
<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}</code></pre>
<p>The above code gets transformed before execution starts. JavaScript moves
the <code>var</code> statements, as well as <code>function</code> declarations, to the top of the 
nearest surrounding scope.</p>
<pre><code>// var statements got moved here
var bar, someValue; // default to &#39;undefined&#39;

// the function declaration got moved up too
function test(data) {
    var goo, i, e; // missing block scope moves these here
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // fails with a TypeError since bar is still &#39;undefined&#39;
someValue = 42; // assignments are not affected by hoisting
bar = function() {};

test();</code></pre>
<p>Missing block scoping will not only move <code>var</code> statements out of loops and
their bodies, it will also make the results of certain <code>if</code> constructs 
non-intuitive.</p>
<p>In the original code, although the <code>if</code> statement seemed to modify the <em>global 
variable</em> <code>goo</code>, it actually modifies the <em>local variable</em> - after hoisting 
has been applied.</p>
<p>Without knowledge of <em>hoisting</em>, one might suspect the code below would raise a
<code>ReferenceError</code>.</p>
<pre><code>// check whether SomeImportantThing has been initialized
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}</code></pre>
<p>But of course, this works due to the fact that the <code>var</code> statement is being 
moved to the top of the <em>global scope</em>.</p>
<pre><code>var SomeImportantThing;

// other code might initialize SomeImportantThing here, or not

// make sure it&#39;s there
if (!SomeImportantThing) {
    SomeImportantThing = {};
}</code></pre>
</div><div><h3>Name Resolution Order</h3>
<p>All scopes in JavaScript, including the <em>global scope</em>, have the special name 
<a href="#function.this"><code>this</code></a>, defined in them, which refers to the <em>current object</em>. </p>
<p>Function scopes also have the name <a href="#function.arguments"><code>arguments</code></a>, defined in
them, which contains the arguments that were passed to the function.</p>
<p>For example, when trying to access a variable named <code>foo</code> inside the scope of a 
function, JavaScript will look up the name in the following order:</p>
<ol>
<li>In case there is a <code>var foo</code> statement in the current scope, use that.</li>
<li>If one of the function parameters is named <code>foo</code>, use that.</li>
<li>If the function itself is called <code>foo</code>, use that.</li>
<li>Go to the next outer scope, and start with <strong>#1</strong> again.</li>
</ol>
<aside>
<p><strong>Note:</strong> Having a parameter called <code>arguments</code> will <strong>prevent</strong> the creation 
of the default <code>arguments</code> object.</p>
</aside>
</div><div><h3>Namespaces</h3>
<p>A common problem associated with having only one global namespace is the
likelihood of running into problems where variable names clash. In JavaScript,
this problem can easily be avoided with the help of <em>anonymous wrappers</em>.</p>
<pre><code>(function() {
    // a self contained &quot;namespace&quot;

    window.foo = function() {
        // an exposed closure
    };

})(); // execute the function immediately</code></pre>
<p>Unnamed functions are considered <a href="#function.general">expressions</a>; so in order to
be callable, they must first be evaluated.</p>
<pre><code>( // evaluate the function inside the parentheses
function() {}
) // and return the function object
() // call the result of the evaluation</code></pre>
<p>There are other ways to evaluate and directly call the function expression
which, while different in syntax, behave the same way.</p>
<pre><code>// A few other styles for directly invoking the 
!function(){}()
+function(){}()
(function(){}());
// and so on...</code></pre>
</div><div><h3>In Conclusion</h3>
<p>It is recommended to always use an <em>anonymous wrapper</em> to encapsulate code in 
its own namespace. This does not only protect code against name clashes, but it 
also allows for better modularization of programs.</p>
<p>Additionally, the use of global variables is considered <strong>bad practice</strong>. <strong>Any</strong>
use of them indicates badly written code that is prone to errors and hard to maintain.</p>
</div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Arrays</h1></header><!-- Articles--><article id="array.general"><h2>Array Iteration and Properties</h2><div><p>Although arrays in JavaScript are objects, there are no good reasons to use
the <a href="#object.forinloop"><code>for in</code></a> loop. In fact, there 
are a number of good reasons <strong>against</strong> the use of <code>for in</code> on arrays.</p>
<aside>
<p><strong>Note:</strong> JavaScript arrays are <strong>not</strong> <em>associative arrays</em>. JavaScript only 
has <a href="#object.general">objects</a> for mapping keys to values. And while associative 
arrays <strong>preserve</strong> order, objects <strong>do not</strong>.</p>
</aside>
<p>Because the <code>for in</code> loop enumerates all the properties that are on the prototype 
chain and because the only way to exclude those properties is to use 
<a href="#object.hasownproperty"><code>hasOwnProperty</code></a>, it is already up to <strong>twenty times</strong> 
slower than a normal <code>for</code> loop.</p>
</div><div><h3>Iteration</h3>
<p>In order to achieve the best performance when iterating over arrays, it is best
to use the classic <code>for</code> loop.</p>
<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}</code></pre>
<p>There is one extra catch in the above example, which is the caching of the 
length of the array via <code>l = list.length</code>.</p>
<p>Although the <code>length</code> property is defined on the array itself, there is still an
overhead for doing the lookup on each iteration of the loop. And while recent 
JavaScript engines <strong>may</strong> apply optimization in this case, there is no way of
telling whether the code will run on one of these newer engines or not. </p>
<p>In fact, leaving out the caching may result in the loop being only <strong>half as
fast</strong> as with the cached length.</p>
</div><div><h3>The <code>length</code> Property</h3>
<p>While the <em>getter</em> of the <code>length</code> property simply returns the number of
elements that are contained in the array, the <em>setter</em> can be used to 
<strong>truncate</strong> the array.</p>
<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo.push(4);
foo; // [1, 2, 3, undefined, undefined, undefined, 4]</code></pre>
<p>Assigning a smaller length truncates the array. Increasing it creates a sparse array.</p>
</div><div><h3>In Conclusion</h3>
<p>For the best performance, it is recommended to always use the plain <code>for</code> loop
and cache the <code>length</code> property. The use of <code>for in</code> on an array is a sign of
badly written code that is prone to bugs and bad performance. </p>
</div></article><article id="array.constructor"><h2>The <code>Array</code> Constructor</h2><div><p>Since the <code>Array</code> constructor is ambiguous in how it deals with its parameters,
it is highly recommended to use the array literal - <code>[]</code> notation - 
when creating new arrays.</p>
<pre><code>[1, 2, 3]; // Result: [1, 2, 3]
new Array(1, 2, 3); // Result: [1, 2, 3]

[3]; // Result: [3]
new Array(3); // Result: []
new Array(&#39;3&#39;) // Result: [&#39;3&#39;]</code></pre>
<p>In cases when there is only one argument passed to the <code>Array</code> constructor
and when that argument is a <code>Number</code>, the constructor will return a new <em>sparse</em> 
array with the <code>length</code> property set to the value of the argument. It should be 
noted that <strong>only</strong> the <code>length</code> property of the new array will be set this way; 
the actual indexes of the array will not be initialized. </p>
<pre><code>var arr = new Array(3);
arr[1]; // undefined
1 in arr; // false, the index was not set</code></pre>
<p>Being able to set the length of the array in advance is only useful in a few
cases, like repeating a string, in which it avoids the use of a loop.</p>
<pre><code>new Array(count + 1).join(stringToRepeat);</code></pre>
</div><div><h3>In Conclusion</h3>
<p>Literals are preferred to the Array constructor. They are shorter, have a clearer syntax, and increase code
readability.</p>
</div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Types</h1></header><!-- Articles--><article id="types.equality"><h2>Equality and Comparisons</h2><div><p>JavaScript has two different ways of comparing the values of objects for equality. </p>
</div><div><h3>The Equality Operator</h3>
<p>The equality operator consists of two equal signs: <code>==</code></p>
<p>JavaScript features <em>weak typing</em>. This means that the equality operator 
<strong>coerces</strong> types in order to compare them.</p>
<pre><code>&quot;&quot;           ==   &quot;0&quot;           // false
0            ==   &quot;&quot;            // true
0            ==   &quot;0&quot;           // true
false        ==   &quot;false&quot;       // false
false        ==   &quot;0&quot;           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
&quot; \t\r\n&quot;    ==   0             // true</code></pre>
<p>The above table shows the results of the type coercion, and it is the main reason 
why the use of <code>==</code> is widely regarded as bad practice. It introduces
hard-to-track-down bugs due to its complicated conversion rules.</p>
<p>Additionally, there is also a performance impact when type coercion is in play;
for example, a string has to be converted to a number before it can be compared
to another number.</p>
</div><div><h3>The Strict Equality Operator</h3>
<p>The strict equality operator consists of <strong>three</strong> equal signs: <code>===</code>.</p>
<p>It works like the normal equality operator, except that strict equality 
operator does <strong>not</strong> perform type coercion between its operands.</p>
<pre><code>&quot;&quot;           ===   &quot;0&quot;           // false
0            ===   &quot;&quot;            // false
0            ===   &quot;0&quot;           // false
false        ===   &quot;false&quot;       // false
false        ===   &quot;0&quot;           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
&quot; \t\r\n&quot;    ===   0             // false</code></pre>
<p>The above results are a lot clearer and allow for early breakage of code. This
hardens code to a certain degree and also gives performance improvements in case
the operands are of different types.</p>
</div><div><h3>Comparing Objects</h3>
<p>While both <code>==</code> and <code>===</code> are called <strong>equality</strong> operators, they behave 
differently when at least one of their operands is an <code>Object</code>.</p>
<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true</code></pre>
<p>Here, both operators compare for <strong>identity</strong> and <strong>not</strong> equality; that is, they
will compare for the same <strong>instance</strong> of the object, much like <code>is</code> in Python 
and pointer comparison in C.</p>
</div><div><h3>In Conclusion</h3>
<p>It is highly recommended to only use the <strong>strict equality</strong> operator. In cases
where types need to be coerced, it should be done <a href="#types.casting">explicitly</a> 
and not left to the language&#39;s complicated coercion rules.</p>
</div></article><article id="types.typeof"><h2>The <code>typeof</code> Operator</h2><div><p>The <code>typeof</code> operator (together with 
<a href="#types.instanceof"><code>instanceof</code></a>) is probably the biggest 
design flaw of JavaScript, as it is almost <strong>completely broken</strong>.</p>
<p>Although <code>instanceof</code> still has limited uses, <code>typeof</code> really has only one
practical use case, which does <strong>not</strong> happen to be checking the type of an 
object. </p>
<aside>
<p><strong>Note:</strong> While <code>typeof</code> can also be called with a function like syntax, i.e.
<code>typeof(obj)</code>, this is not a function call. The parentheses behave as normal
and the return value will be used as the operand of the <code>typeof</code> operator.
There is <strong>no</strong> <code>typeof</code> function.</p>
</aside>
</div><div><h3>The JavaScript Type Table</h3>
<pre><code>Value               Class      Type
-------------------------------------
&quot;foo&quot;               String     string
new String(&quot;foo&quot;)   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function(&quot;&quot;)    Function   function
/abc/g              RegExp     object (function in Nitro/V8)
new RegExp(&quot;meow&quot;)  RegExp     object (function in Nitro/V8)
{}                  Object     object
new Object()        Object     object</code></pre>
<p>In the above table, <em>Type</em> refers to the value that the <code>typeof</code> operator returns.
As can be clearly seen, this value is anything but consistent.</p>
<p>The <em>Class</em> refers to the value of the internal <code>[[Class]]</code> property of an object.</p>
<aside>
<p><strong>From the Specification:</strong> The value of <code>[[Class]]</code> can be one of the
following strings. <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, 
<code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>
<p>In order to retrieve the value of <code>[[Class]]</code>, one has to make use of the
<code>toString</code> method of <code>Object.prototype</code>.</p>
</div><div><h3>The Class of an Object</h3>
<p>The specification gives exactly one way of accessing the <code>[[Class]]</code> value,
with the use of <code>Object.prototype.toString</code>. </p>
<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true</code></pre>
<p>In the above example, <code>Object.prototype.toString</code> gets called with the value of
<a href="#function.this">this</a> being set to the object whose <code>[[Class]]</code> value should be 
retrieved.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> For convenience the return value of <code>Object.prototype.toString</code> 
for both <code>null</code> and <code>undefined</code> was <strong>changed</strong> from <code>Object</code> to <code>Null</code> and 
<code>Undefined</code> in ECMAScript 5.</p>
</aside>
</div><div><h3>Testing for Undefined Variables</h3>
<pre><code>typeof foo !== &#39;undefined&#39;</code></pre>
<p>The above will check whether <code>foo</code> was actually declared or not; just 
referencing it would result in a <code>ReferenceError</code>. This is the only thing
<code>typeof</code> is actually useful for.</p>
</div><div><h3>In Conclusion</h3>
<p>In order to check the type of an object, it is highly recommended to use 
<code>Object.prototype.toString</code> because this is the only reliable way of doing so. 
As shown in the above type table, some return values of <code>typeof</code> are not defined 
in the specification; thus, they can differ between implementations.</p>
<p>Unless checking whether a variable is defined, <code>typeof</code> should be avoided.</p>
</div></article><article id="types.instanceof"><h2>The <code>instanceof</code> Operator</h2><div><p>The <code>instanceof</code> operator compares the constructors of its two operands. It is 
only useful when comparing custom made objects. Used on built-in types, it is
nearly as useless as the <a href="#types.typeof">typeof operator</a>.</p>
</div><div><h3>Comparing Custom Objects</h3>
<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// This just sets Bar.prototype to the function object Foo,
// but not to an actual instance of Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false</code></pre>
</div><div><h3>Using <code>instanceof</code> with Native Types</h3>
<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false</code></pre>
<p>One important thing to note here is that <code>instanceof</code> does not work on objects 
that originate from different JavaScript contexts (e.g. different documents
in a web browser), since their constructors will not be the exact same object.</p>
</div><div><h3>In Conclusion</h3>
<p>The <code>instanceof</code> operator should <strong>only</strong> be used when dealing with custom made 
objects that originate from the same JavaScript context. Just like the
<a href="#types.typeof"><code>typeof</code></a> operator, every other use of it should be <strong>avoided</strong>.</p>
</div></article><article id="types.casting"><h2>Type Casting</h2><div><p>JavaScript is a <em>weakly typed</em> language, so it will apply <em>type coercion</em>
<strong>wherever</strong> possible.</p>
<pre><code>// These are true
new Number(10) == 10; // Number.toString() is converted
                      // back to a number

10 == &#39;10&#39;;           // Strings gets converted to Number
10 == &#39;+10 &#39;;         // More string madness
10 == &#39;010&#39;;          // And more 
isNaN(null) == false; // null converts to 0
                      // which of course is not NaN

// These are false
10 == 010;
10 == &#39;-10&#39;;</code></pre>
<aside class="es5"><p><strong>ES5 Note:</strong> Number literals that start with a <code>0</code> are interpreted as octal 
(Base 8). Octal support for these has been <strong>removed</strong> in ECMAScript 5 strict 
mode.</p>
</aside>
<p>To avoid the issues above, use of the <a href="#types.equality">strict equal operator</a> 
is <strong>highly</strong> recommended. Although this avoids a lot of common pitfalls, there 
are still many further issues that arise from JavaScript&#39;s weak typing system.</p>
</div><div><h3>Constructors of Built-In Types</h3>
<p>The constructors of the built in types like <code>Number</code> and <code>String</code> behave
differently when being used with the <code>new</code> keyword and without it.</p>
<pre><code>new Number(10) === 10;     // False, Object and Number
Number(10) === 10;         // True, Number and Number
new Number(10) + 0 === 10; // True, due to implicit conversion</code></pre>
<p>Using a built-in type like <code>Number</code> as a constructor will create a new <code>Number</code> 
object, but leaving out the <code>new</code> keyword will make the <code>Number</code> function behave
like a converter.</p>
<p>In addition, passing literals or non-object values will result in even more
type coercion.</p>
<p>The best option is to cast to one of the three possible types <strong>explicitly</strong>.</p>
</div><div><h3>Casting to a String</h3>
<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true</code></pre>
<p>By prepending an empty string, a value can easily be cast to a string.</p>
</div><div><h3>Casting to a Number</h3>
<pre><code>+&#39;10&#39; === 10; // true</code></pre>
<p>Using the <strong>unary</strong> plus operator, it is possible to cast to a number.</p>
</div><div><h3>Casting to a Boolean</h3>
<p>By using the <strong>not</strong> operator twice, a value can be converted a boolean.</p>
<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true</code></pre>
</div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Core</h1></header><!-- Articles--><article id="core.eval"><h2>Why Not to Use <code>eval</code></h2><div><p>The <code>eval</code> function will execute a string of JavaScript code in the local scope.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1</code></pre>
<p>However, <code>eval</code> only executes in the local scope when it is being called
directly <em>and</em> when the name of the called function is actually <code>eval</code>.</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3</code></pre>
<p>The use of <code>eval</code> should be avoided. 99.9% of its &quot;uses&quot; can be achieved
<strong>without</strong> it.</p>
</div><div><h3><code>eval</code> in Disguise</h3>
<p>The <a href="#other.timeouts">timeout functions</a> <code>setTimeout</code> and <code>setInterval</code> can both 
take a string as their first argument. This string will <strong>always</strong> get executed 
in the global scope since <code>eval</code> is not being called directly in that case.</p>
</div><div><h3>Security Issues</h3>
<p><code>eval</code> also is a security problem, because it executes <strong>any</strong> code given to it.
It should <strong>never</strong> be used with strings of unknown or untrusted origins.</p>
</div><div><h3>In Conclusion</h3>
<p><code>eval</code> should never be used. Any code that makes use of it should be questioned
in its workings, performance and security. If something requires <code>eval</code> in
order to work, it should <strong>not</strong> be used in the first place.  A <em>better design</em>
should be used, that does not require the use of <code>eval</code>.</p>
</div></article><article id="core.undefined"><h2><code>undefined</code> and <code>null</code></h2><div><p>JavaScript has two distinct values for nothing, <code>null</code> and <code>undefined</code>, with
the latter being more useful.</p>
</div><div><h3>The Value <code>undefined</code></h3>
<p><code>undefined</code> is a type with exactly one value: <code>undefined</code>.</p>
<p>The language also defines a global variable that has the value of <code>undefined</code>;
this variable is also called <code>undefined</code>. However, this variable is <strong>neither</strong> a constant
nor a keyword of the language. This means that its <em>value</em> can be easily 
overwritten.</p>
<aside class="es5"><p><strong>ES5 Note:</strong> <code>undefined</code> in ECMAScript 5 is <strong>no longer</strong> <em>writable</em> in strict
mode, but its name can still be shadowed by for example a function with the name 
<code>undefined</code>.</p>
</aside>
<p>Here are some examples of when the value <code>undefined</code> is returned:</p>
<ul>
<li>Accessing the (unmodified) global variable <code>undefined</code>.</li>
<li>Accessing a declared <em>but not</em> yet initialized variable.</li>
<li>Implicit returns of functions due to missing <code>return</code> statements.</li>
<li><code>return</code> statements that do not explicitly return anything.</li>
<li>Lookups of non-existent properties.</li>
<li>Function parameters that do not have any explicit value passed.</li>
<li>Anything that has been set to the value of <code>undefined</code>.</li>
<li>Any expression in the form of <code>void(expression)</code></li>
</ul>
</div><div><h3>Handling Changes to the Value of <code>undefined</code></h3>
<p>Since the global variable <code>undefined</code> only holds a copy of the actual <em>value</em> of 
<code>undefined</code>, assigning a new value to it does <strong>not</strong> change the value of the 
<em>type</em> <code>undefined</code>.</p>
<p>Still, in order to compare something against the value of <code>undefined</code>, it is
necessary to retrieve the value of <code>undefined</code> first.</p>
<p>To protect code against a possible overwritten <code>undefined</code> variable, a common
technique used is to add an additional parameter to an <a href="#function.scopes">anonymous
wrapper</a> that gets no argument passed to it.</p>
<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // undefined in the local scope does 
    // now again refer to the value `undefined`

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Another way to achieve the same effect would be to use a declaration inside the 
wrapper.</p>
<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);</code></pre>
<p>The only difference here is that this version results in 4 more bytes being
used in case it is minified, and there is no other <code>var</code> statement inside the
anonymous wrapper.</p>
</div><div><h3>Uses of <code>null</code></h3>
<p>While <code>undefined</code> in the context of the JavaScript language is mostly used in
the sense of a traditional <em>null</em>, the actual <code>null</code> (both a literal and a type)
is more or less just another data type.</p>
<p>It is used in some JavaScript internals (like declaring the end of the
prototype chain by setting <code>Foo.prototype = null</code>), but in almost all cases, it
can be replaced by <code>undefined</code>.</p>
</div></article><article id="core.semicolon"><h2>Automatic Semicolon Insertion</h2><div><p>Although JavaScript has C style syntax, it does <strong>not</strong> enforce the use of
semicolons in the source code, so it is possible to omit them.</p>
<p>JavaScript is not a semicolon-less language. In fact, it needs the 
semicolons in order to understand the source code. Therefore, the JavaScript
parser <strong>automatically</strong> inserts them whenever it encounters a parse
error due to a missing semicolon.</p>
<pre><code>var foo = function() {
} // parse error, semicolon expected
test()</code></pre>
<p>Insertion happens, and the parser tries again.</p>
<pre><code>var foo = function() {
}; // no error, parser continues
test()</code></pre>
<p>The automatic insertion of semicolon is considered to be one of <strong>biggest</strong>
design flaws in the language because it <em>can</em> change the behavior of code.</p>
</div><div><h3>How it Works</h3>
<p>The code below has no semicolons in it, so it is up to the parser to decide where
to insert them.</p>
<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;testing!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)</code></pre>
<p>Below is the result of the parser&#39;s &quot;guessing&quot; game.</p>
<pre><code>(function(window, undefined) {
    function test(options) {

        // Not inserted, lines got merged
        log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- inserted

        options.value.test(
            &#39;long string to pass here&#39;,
            &#39;and another long string to pass&#39;
        ); // &lt;- inserted

        return; // &lt;- inserted, breaks the return statement
        { // treated as a block

            // a label and a single expression statement
            foo: function() {} 
        }; // &lt;- inserted
    }
    window.test = test; // &lt;- inserted

// The lines got merged again
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- inserted

})(window); //&lt;- inserted</code></pre>
<aside>
<p><strong>Note:</strong> The JavaScript parser does not &quot;correctly&quot; handle return statements 
that are followed by a new line. While this is not necessarily the fault of
the automatic semicolon insertion, it can still be an unwanted side-effect. </p>
</aside>
<p>The parser drastically changed the behavior of the code above. In certain cases,
it does the <strong>wrong thing</strong>.</p>
</div><div><h3>Leading Parenthesis</h3>
<p>In case of a leading parenthesis, the parser will <strong>not</strong> insert a semicolon.</p>
<pre><code>log(&#39;testing!&#39;)
(options.list || []).forEach(function(i) {})</code></pre>
<p>This code gets transformed into one line.</p>
<pre><code>log(&#39;testing!&#39;)(options.list || []).forEach(function(i) {})</code></pre>
<p>Chances are <strong>very</strong> high that <code>log</code> does <strong>not</strong> return a function; therefore,
the above will yield a <code>TypeError</code> stating that <code>undefined is not a function</code>.</p>
</div><div><h3>In Conclusion</h3>
<p>It is highly recommended to <strong>never</strong> omit semicolons. It is also recommended
that braces be kept on the same line as their corresponding statements and to
never omit them for single-line <code>if</code> / <code>else</code> statements. These measures will
not only improve the consistency of the code, but they will also prevent the
JavaScript parser from changing code behavior.</p>
</div></article><article id="core.delete"><h2>The <code>delete</code> Operator</h2><div><p>In short, it&#39;s <em>impossible</em> to delete global variables, functions and some other
stuff in JavaScript which have a <code>DontDelete</code> attribute set.</p>
</div><div><h3>Global code and Function code</h3>
<p>When a variable or a function is defined in a global or a <a href="#function.scopes">function
scope</a> it is a property of either the Activation object or
the Global object. Such properties have a set of attributes, one of which is
<code>DontDelete</code>. Variable and function declarations in global and function code
always create properties with <code>DontDelete</code>, and therefore cannot be deleted.</p>
<pre><code>// global variable:
var a = 1; // DontDelete is set
delete a; // false
a; // 1

// normal function:
function f() {} // DontDelete is set
delete f; // false
typeof f; // &quot;function&quot;

// reassigning doesn&#39;t help:
f = 1;
delete f; // false
f; // 1</code></pre>
</div><div><h3>Explicit properties</h3>
<p>Explicitly set properties can be deleted normally.</p>
<pre><code>// explicitly set property:
var obj = {x: 1};
obj.y = 2;
delete obj.x; // true
delete obj.y; // true
obj.x; // undefined
obj.y; // undefined</code></pre>
<p>In the example above, <code>obj.x</code> and <code>obj.y</code> can be deleted because they have no 
<code>DontDelete</code> atribute. That&#39;s why the example below works too.</p>
<pre><code>// this works fine, except for IE:
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // true - just a global var
delete GLOBAL_OBJECT.a; // true
GLOBAL_OBJECT.a; // undefined</code></pre>
<p>Here we use a trick to delete <code>a</code>. <a href="#function.this"><code>this</code></a> here refers 
to the Global object and we explicitly declare variable <code>a</code> as its property 
which allows us to delete it.</p>
<p>IE (at least 6-8) has some bugs, so the code above doesn&#39;t work.</p>
</div><div><h3>Function arguments and built-ins</h3>
<p>Functions&#39; normal arguments, <a href="#function.arguments"><code>arguments</code> objects</a> 
and built-in properties also have <code>DontDelete</code> set.</p>
<pre><code>// function arguments and properties:
(function (x) {

  delete arguments; // false
  typeof arguments; // &quot;object&quot;

  delete x; // false
  x; // 1

  function f(){}
  delete f.length; // false
  typeof f.length; // &quot;number&quot;

})(1);</code></pre>
</div><div><h3>Host objects</h3>
<p>The behaviour of <code>delete</code> operator can be unpredictable for hosted objects. Due
to the specification, host objects are allowed to implement any kind of behavior. </p>
</div><div><h3>In conclusion</h3>
<p>The <code>delete</code> operator often has unexpected behaviour and can only be safely
used to delete explicitly set properties on normal objects.</p>
</div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Other</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> and <code>setInterval</code></h2><div><p>Since JavaScript is asynchronous, it is possible to schedule the execution of a 
function using the <code>setTimeout</code> and <code>setInterval</code> functions.</p>
<aside>
<p><strong>Note:</strong> Timeouts are <strong>not</strong> part of the ECMAScript Standard. They are
implemented as part of the <a href="http://en.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>.</p>
</aside>
<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // returns a Number &gt; 0</code></pre>
<p>When <code>setTimeout</code> is called, it returns the ID of the timeout and schedule
<code>foo</code> to run <strong>approximately</strong> one thousand milliseconds in the future. 
<code>foo</code> will then be executed <strong>once</strong>.</p>
<p>Depending on the timer resolution of the JavaScript engine running the code, as
well as the fact that JavaScript is single threaded and other code that gets
executed might block the thread, it is by <strong>no means</strong> a safe bet that one will
get the exact delay specified in the <code>setTimeout</code> call.</p>
<p>The function that was passed as the first parameter will get called by the
<em>global object</em>, which means that <a href="#function.this"><code>this</code></a> inside the called function 
refers to the global object.</p>
<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this refers to the global object
        console.log(this.value); // will log undefined
    };
    setTimeout(this.method, 500);
}
new Foo();</code></pre>
<aside>
<p><strong>Note:</strong> As <code>setTimeout</code> takes a <strong>function object</strong> as its first parameter, a
common mistake is to use <code>setTimeout(foo(), 1000)</code>, which will use the 
<strong>return value</strong> of the call <code>foo</code> and <strong>not</strong> <code>foo</code>. This is, most of the time, 
a silent error, since when the function returns <code>undefined</code> <code>setTimeout</code> will 
<strong>not</strong> raise any error.</p>
</aside>
</div><div><h3>Stacking Calls with <code>setInterval</code></h3>
<p>While <code>setTimeout</code> only runs the function once, <code>setInterval</code> - as the name 
suggests - will execute the function <strong>every</strong> <code>X</code> milliseconds, but its use is 
discouraged. </p>
<p>When code that is being executed blocks the timeout call, <code>setInterval</code> will 
still issue more calls to the specified function. This can, especially with small
intervals, result in function calls stacking up.</p>
<pre><code>function foo(){
    // something that blocks for 1 second
}
setInterval(foo, 1000);</code></pre>
<p>In the above code, <code>foo</code> will get called once and will then block for one second.</p>
<p>While <code>foo</code> blocks the code, <code>setInterval</code> will still schedule further calls to
it. Now, when <code>foo</code> has finished, there will already be <strong>ten</strong> further calls to
it waiting for execution.</p>
</div><div><h3>Dealing with Possible Blocking Code</h3>
<p>The easiest solution, as well as most controllable solution, is to use <code>setTimeout</code> within
the function itself.</p>
<pre><code>function foo(){
    // something that blocks for 1 second
    setTimeout(foo, 1000);
}
foo();</code></pre>
<p>Not only does this encapsulate the <code>setTimeout</code> call, but it also prevents the
stacking of calls and gives additional control. <code>foo</code> itself can now decide 
whether it wants to run again or not.</p>
</div><div><h3>Manually Clearing Timeouts</h3>
<p>Clearing timeouts and intervals works by passing the respective ID to
<code>clearTimeout</code> or <code>clearInterval</code>, depending on which <code>set</code> function was used
in the first place.</p>
<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);</code></pre>
</div><div><h3>Clearing All Timeouts</h3>
<p>As there is no built-in method for clearing all timeouts and/or intervals, 
it is necessary to use brute force in order to achieve this functionality.</p>
<pre><code>// clear &quot;all&quot; timeouts
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}</code></pre>
<p>But there might still be timeouts that are unaffected by this arbitrary number.
Another way of doing this is to consider that the ID given to a timeout is
incremented by one every time you call <code>setTimeout</code>.</p>
<pre><code>// clear &quot;all&quot; timeouts
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}</code></pre>
<p>Even though this works on all major browsers today, it isn&#39;t specified that
the IDs should be ordered that way and it may change. Therefore, it is instead
recommended to keep track of all the timeout IDs, so they can be cleared
specifically.</p>
</div><div><h3>Hidden Use of <code>eval</code></h3>
<p><code>setTimeout</code> and <code>setInterval</code> can also take a string as their first parameter.
This feature should <strong>never</strong> be used because it internally makes use of <code>eval</code>.</p>
<aside>
<p><strong>Note:</strong> Since the timeout functions are <strong>not</strong> specified by the ECMAScript
standard, the exact workings when a string is passed to them might differ in
various JavaScript implementations. For example, Microsoft&#39;s JScript uses
the <code>Function</code> constructor in place of <code>eval</code>.</p>
</aside>
<pre><code>function foo() {
    // will get called
}

function bar() {
    function foo() {
        // never gets called
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();</code></pre>
<p>Since <code>eval</code> is not getting called <a href="#core.eval">directly</a> in this case, the string 
passed to <code>setTimeout</code> will be executed in the <em>global scope</em>; thus, it will 
not use the local variable <code>foo</code> from the scope of <code>bar</code>.</p>
<p>It is further recommended to <strong>not</strong> use a string to pass arguments to the
function that will get called by either of the timeout functions. </p>
<pre><code>function foo(a, b, c) {}

// NEVER use this
setTimeout(&#39;foo(1, 2, 3)&#39;, 1000)

// Instead use an anonymous function
setTimeout(function() {
    foo(a, b, c);
}, 1000)</code></pre>
<aside>
<p><strong>Note:</strong> While it is also possible to use the syntax 
<code>setTimeout(foo, 1000, a, b, c)</code>, it is not recommended, as its use may lead
to subtle errors when used with <a href="#function.this">methods</a>. </p>
</aside>
</div><div><h3>In Conclusion</h3>
<p>A string should <strong>never</strong> be used as the parameter of <code>setTimeout</code> or 
<code>setInterval</code>. It is a clear sign of <strong>really</strong> bad code, when arguments need 
to be supplied to the function that gets called. An <em>anonymous function</em> should
be passed that then takes care of the actual call.</p>
<p>Furthermore, the use of <code>setInterval</code> should be avoided because its scheduler is not
blocked by executing JavaScript.</p>
</div></article></section><!-- Footer--><footer><p>Copyright &copy; 2011. Built with
 <a href="http://nodejs.org/">Node.js </a>using a<a href="https://github.com/visionmedia/jade/">jade </a>template. 
Hosted by <a href="http://cramerdev.com">Cramer Development</a>.</p></footer><script src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="javascript/prettify.js"></script><script src="javascript/plugin.js"></script><script src="javascript/garden.js"></script></body></html>